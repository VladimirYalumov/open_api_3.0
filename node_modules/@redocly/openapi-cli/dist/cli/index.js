#!/usr/bin/env node
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _chalk = _interopRequireDefault(require("chalk"));

var _commander = _interopRequireDefault(require("commander"));

var _fs = _interopRequireDefault(require("fs"));

var _path = require("path");

var chockidar = _interopRequireWildcard(require("chokidar"));

var _validate = require("../validate");

var _bundle = require("../bundle");

var _utils = require("../utils");

var _outputMessages = require("./outputMessages");

var _config = require("../config");

var _previewDocs = _interopRequireDefault(require("../preview-docs"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const validateFile = (filePath, options, cmdObj) => {
  let result;

  if (!_fs.default.existsSync(filePath) && (0, _utils.isFullyQualifiedUrl)(filePath)) {
    process.stdout.write('Will validate from URL\n');
    result = (0, _validate.validateFromUrl)(filePath, options);
  } else {
    result = (0, _validate.validateFromFile)(filePath, options);
  }

  const resultStats = (0, _outputMessages.outputMessages)(result, cmdObj);
  process.stdout.write(`${_chalk.default.blueBright(filePath)} results. Errors: ${resultStats.totalErrors}, warnings: ${resultStats.totalWarnings}\n`);
  return {
    errors: resultStats.totalErrors,
    warnings: resultStats.totalWarnings
  };
};

const cli = () => {
  const f = _fs.default.readFileSync(`${__dirname}/../package.json`, 'utf-8');

  const {
    version
  } = JSON.parse(f);

  _commander.default.version(version, '-v, --version', 'Output current version of the OpenAPI CLI.');

  _commander.default.command('bundle [entryPoints...]').description('Create a bundle using <entryPoint> as a root document.').option('-o, --output <outputName>', 'Filename or folder for the bundle.').option('--short', 'Reduce output in case of bundling errors.').option('--ext <ext>', 'Output extension: json, yaml or yml').option('-f, --force', 'Produce bundle output file even if validation errors were encountered').action((entryPoints, cmdObj) => {
    if (cmdObj.ext && ['yaml', 'yml', 'json'].indexOf(cmdObj.ext) === -1) {
      process.stdout.write('Unsupported value for --ext option. Supported values are: yaml, yml or json');
      process.exit(1);
    }

    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    const isOutputDir = cmdObj.output && !(0, _path.extname)(cmdObj.output);
    const ext = cmdObj.ext || (0, _path.extname)(cmdObj.output || '').substring(1) || 'yaml';
    const dir = isOutputDir ? cmdObj.output : (0, _path.dirname)(cmdObj.output || '');
    const results = {
      errors: 0,
      warnings: 0
    };
    entryPoints.forEach(entryPoint => {
      let output;

      if (cmdObj.output) {
        const fileName = isOutputDir ? (0, _path.basename)(entryPoint, (0, _path.extname)(entryPoint)) : (0, _path.basename)(cmdObj.output, `.${ext}`);
        output = (0, _path.join)(dir, `${fileName}.${ext}`);
      }

      const bundlingStatus = (0, _bundle.bundleToFile)(entryPoint, output, cmdObj.force);
      const resultStats = (0, _outputMessages.outputMessages)(bundlingStatus, cmdObj);

      if (resultStats.totalErrors === 0) {
        // we do not want to output anything to stdout if it's being piped.
        if (output) {
          process.stdout.write(`Created a bundle for ${entryPoint} at ${output}\n`);
        }
      } else {
        if (cmdObj.force) {
          process.stderr.write(`Created a bundle for ${entryPoint} at ${output}. Errors ignored because of --force\n`);
        } else {
          process.stderr.write(`Errors encountered while bundling ${entryPoint}: bundle not created (use --force to ignore errors)\n`);
        }

        results.errors += resultStats.totalErrors;
        results.warnings += resultStats.totalWarnings;
      }
    });
    process.exit(results.errors === 0 || cmdObj.force ? 0 : 1);
  });

  _commander.default.command('validate [entryPoints...]').description('Validate given OpenAPI 3 definition file.').option('--short', 'Reduce output to required minimun').option('--no-frame', 'Print no codeframes with errors.').option('--config <path>', 'Specify custom yaml or json config').action((entryPoints, cmdObj) => {
    const options = {};
    const results = {
      errors: 0,
      warnings: 0
    };
    const config = (0, _config.getConfig)({}); // eslint-disable-next-line no-param-reassign

    entryPoints = (0, _config.getFallbackEntryPointsOrExit)(entryPoints, config);
    options.codeframes = cmdObj.frame;
    if (cmdObj.config) options.configPath = cmdObj.config;

    for (let i = 0; i < entryPoints.length; i++) {
      (0, _outputMessages.printValidationHeader)(entryPoints[i]);
      const msgs = validateFile(entryPoints[i], options, cmdObj);
      results.errors += msgs.errors;
      results.warnings += msgs.warnings;
    }

    if (entryPoints.length > 1) {
      process.stdout.write(`Total results. Errors: ${results.errors}, warnings: ${results.warnings}\n`);
    }

    process.exit(results.errors > 0 ? 1 : 0);
  });

  function myParseInt(value) {
    return parseInt(value, 10);
  }

  _commander.default.command('preview-docs [entryPoint]').description('Preview API Reference docs for the specified entrypoint OAS definition').option('-p, --port <value>', 'Preview port', myParseInt, 8080).action(async (entryPoint, cmdObj) => {
    const output = 'dist/openapi.yaml';
    let config = (0, _config.getConfig)({});

    if (!entryPoint) {
      // eslint-disable-next-line no-param-reassign, prefer-destructuring
      entryPoint = (0, _config.getFallbackEntryPointsOrExit)([], config)[0];
    }

    let cachedBundle;
    const deps = new Set();

    async function getBundle() {
      return cachedBundle;
    }

    function updateBundle() {
      cachedBundle = new Promise(resolve => {
        process.stdout.write('\nBundling...\n\n');
        const {
          bundle: openapiBundle,
          result,
          fileDependencies
        } = (0, _bundle.bundle)(entryPoint, output, {
          lint: {
            codeframes: false
          }
        });
        const removed = [...deps].filter(x => !fileDependencies.has(x));
        watcher.unwatch(removed);
        watcher.add([...fileDependencies]);
        deps.clear();
        fileDependencies.forEach(deps.add, deps);
        const resultStats = (0, _outputMessages.outputMessages)(result, {
          short: true
        });

        if (resultStats.totalErrors === 0) {
          process.stdout.write(resultStats.totalErrors === 0 ? `Created a bundle for ${entryPoint} ${resultStats.totalWarnings > 0 ? 'with warnings' : 'successfully'}\n` : _chalk.default.yellow(`Created a bundle for ${entryPoint} with errors. Docs may be broken or not accurate\n`));
        }

        resolve(openapiBundle);
      });
    }

    setImmediate(() => updateBundle()); // initial cache

    const hotClients = await (0, _previewDocs.default)(cmdObj.port, {
      getBundle,
      getOptions: () => config.referenceDocs
    });
    const watcher = chockidar.watch([entryPoint, config.configPath], {
      disableGlobbing: true,
      ignoreInitial: true
    });
    const debouncedUpdatedeBundle = (0, _utils.debounce)(async () => {
      updateBundle();
      await cachedBundle;
      hotClients.broadcast('{"type": "reload", "bundle": true}');
    }, 2000);

    const changeHandler = async (type, file) => {
      process.stdout.write(`${_chalk.default.green('watch')} ${type} ${_chalk.default.blue(file)}\n`);

      if (file === config.configPath) {
        config = (0, _config.getConfig)({
          configPath: file
        });
        hotClients.broadcast(JSON.stringify({
          type: 'reload'
        }));
        return;
      }

      debouncedUpdatedeBundle();
    };

    watcher.on('change', changeHandler.bind(undefined, 'changed'));
    watcher.on('add', changeHandler.bind(undefined, 'added'));
    watcher.on('unlink', changeHandler.bind(undefined, 'removed'));
    watcher.on('ready', () => {
      process.stdout.write(`\n  ðŸ‘€  Watching ${_chalk.default.blue(entryPoint)} and all related resources for changes\n`);
    });
  });

  _commander.default.on('command:*', () => {
    process.stderr.write(`\nUnknown command ${_commander.default.args.join(' ')}\n\n`);

    _commander.default.outputHelp();
  });

  if (process.argv.length === 2) process.argv.push('-h');

  _commander.default.parse(process.argv);
};

var _default = cli;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jbGkvaW5kZXguanMiXSwibmFtZXMiOlsidmFsaWRhdGVGaWxlIiwiZmlsZVBhdGgiLCJvcHRpb25zIiwiY21kT2JqIiwicmVzdWx0IiwiZnMiLCJleGlzdHNTeW5jIiwicHJvY2VzcyIsInN0ZG91dCIsIndyaXRlIiwicmVzdWx0U3RhdHMiLCJjaGFsayIsImJsdWVCcmlnaHQiLCJ0b3RhbEVycm9ycyIsInRvdGFsV2FybmluZ3MiLCJlcnJvcnMiLCJ3YXJuaW5ncyIsImNsaSIsImYiLCJyZWFkRmlsZVN5bmMiLCJfX2Rpcm5hbWUiLCJ2ZXJzaW9uIiwiSlNPTiIsInBhcnNlIiwicHJvZ3JhbSIsImNvbW1hbmQiLCJkZXNjcmlwdGlvbiIsIm9wdGlvbiIsImFjdGlvbiIsImVudHJ5UG9pbnRzIiwiZXh0IiwiaW5kZXhPZiIsImV4aXQiLCJjb25maWciLCJpc091dHB1dERpciIsIm91dHB1dCIsInN1YnN0cmluZyIsImRpciIsInJlc3VsdHMiLCJmb3JFYWNoIiwiZW50cnlQb2ludCIsImZpbGVOYW1lIiwiYnVuZGxpbmdTdGF0dXMiLCJmb3JjZSIsInN0ZGVyciIsImNvZGVmcmFtZXMiLCJmcmFtZSIsImNvbmZpZ1BhdGgiLCJpIiwibGVuZ3RoIiwibXNncyIsIm15UGFyc2VJbnQiLCJ2YWx1ZSIsInBhcnNlSW50IiwiY2FjaGVkQnVuZGxlIiwiZGVwcyIsIlNldCIsImdldEJ1bmRsZSIsInVwZGF0ZUJ1bmRsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiYnVuZGxlIiwib3BlbmFwaUJ1bmRsZSIsImZpbGVEZXBlbmRlbmNpZXMiLCJsaW50IiwicmVtb3ZlZCIsImZpbHRlciIsIngiLCJoYXMiLCJ3YXRjaGVyIiwidW53YXRjaCIsImFkZCIsImNsZWFyIiwic2hvcnQiLCJ5ZWxsb3ciLCJzZXRJbW1lZGlhdGUiLCJob3RDbGllbnRzIiwicG9ydCIsImdldE9wdGlvbnMiLCJyZWZlcmVuY2VEb2NzIiwiY2hvY2tpZGFyIiwid2F0Y2giLCJkaXNhYmxlR2xvYmJpbmciLCJpZ25vcmVJbml0aWFsIiwiZGVib3VuY2VkVXBkYXRlZGVCdW5kbGUiLCJicm9hZGNhc3QiLCJjaGFuZ2VIYW5kbGVyIiwidHlwZSIsImZpbGUiLCJncmVlbiIsImJsdWUiLCJzdHJpbmdpZnkiLCJvbiIsImJpbmQiLCJ1bmRlZmluZWQiLCJhcmdzIiwiam9pbiIsIm91dHB1dEhlbHAiLCJhcmd2IiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBRUEsTUFBTUEsWUFBWSxHQUFHLENBQUNDLFFBQUQsRUFBV0MsT0FBWCxFQUFvQkMsTUFBcEIsS0FBK0I7QUFDbEQsTUFBSUMsTUFBSjs7QUFFQSxNQUFJLENBQUNDLFlBQUdDLFVBQUgsQ0FBY0wsUUFBZCxDQUFELElBQTRCLGdDQUFvQkEsUUFBcEIsQ0FBaEMsRUFBK0Q7QUFDN0RNLElBQUFBLE9BQU8sQ0FBQ0MsTUFBUixDQUFlQyxLQUFmLENBQXFCLDBCQUFyQjtBQUNBTCxJQUFBQSxNQUFNLEdBQUcsK0JBQWdCSCxRQUFoQixFQUEwQkMsT0FBMUIsQ0FBVDtBQUNELEdBSEQsTUFHTztBQUNMRSxJQUFBQSxNQUFNLEdBQUcsZ0NBQWlCSCxRQUFqQixFQUEyQkMsT0FBM0IsQ0FBVDtBQUNEOztBQUNELFFBQU1RLFdBQVcsR0FBRyxvQ0FBZU4sTUFBZixFQUF1QkQsTUFBdkIsQ0FBcEI7QUFDQUksRUFBQUEsT0FBTyxDQUFDQyxNQUFSLENBQWVDLEtBQWYsQ0FDRyxHQUFFRSxlQUFNQyxVQUFOLENBQWlCWCxRQUFqQixDQUEyQixxQkFBb0JTLFdBQVcsQ0FBQ0csV0FBWSxlQUFjSCxXQUFXLENBQUNJLGFBQWMsSUFEcEg7QUFJQSxTQUFPO0FBQ0xDLElBQUFBLE1BQU0sRUFBRUwsV0FBVyxDQUFDRyxXQURmO0FBRUxHLElBQUFBLFFBQVEsRUFBRU4sV0FBVyxDQUFDSTtBQUZqQixH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QUF1QiwwQ0FBaEU7QUFDRCxLQUZEO0FBR0QsR0FyRkg7O0FBdUZBaEIscUJBQVFvRSxFQUFSLENBQVcsV0FBWCxFQUF3QixNQUFNO0FBQzVCckYsSUFBQUEsT0FBTyxDQUFDcUMsTUFBUixDQUFlbkMsS0FBZixDQUFzQixxQkFBb0JlLG1CQUFRdUUsSUFBUixDQUFhQyxJQUFiLENBQWtCLEdBQWxCLENBQXVCLE1BQWpFOztBQUNBeEUsdUJBQVF5RSxVQUFSO0FBQ0QsR0FIRDs7QUFLQSxNQUFJMUYsT0FBTyxDQUFDMkYsSUFBUixDQUFhakQsTUFBYixLQUF3QixDQUE1QixFQUErQjFDLE9BQU8sQ0FBQzJGLElBQVIsQ0FBYUMsSUFBYixDQUFrQixJQUFsQjs7QUFFL0IzRSxxQkFBUUQsS0FBUixDQUFjaEIsT0FBTyxDQUFDMkYsSUFBdEI7QUFDRCxDQXpNRDs7ZUEyTWVqRixHIiwic291cmNlc0NvbnRlbnQiOlsiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG5pbXBvcnQgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHByb2dyYW0gZnJvbSAnY29tbWFuZGVyJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQge1xuICBqb2luLCBiYXNlbmFtZSwgZGlybmFtZSwgZXh0bmFtZSxcbn0gZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjaG9ja2lkYXIgZnJvbSAnY2hva2lkYXInO1xuXG5pbXBvcnQgeyB2YWxpZGF0ZUZyb21GaWxlLCB2YWxpZGF0ZUZyb21VcmwgfSBmcm9tICcuLi92YWxpZGF0ZSc7XG5pbXBvcnQgeyBidW5kbGUsIGJ1bmRsZVRvRmlsZSB9IGZyb20gJy4uL2J1bmRsZSc7XG5cbmltcG9ydCB7IGlzRnVsbHlRdWFsaWZpZWRVcmwsIGRlYm91bmNlIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5pbXBvcnQgeyBvdXRwdXRNZXNzYWdlcywgcHJpbnRWYWxpZGF0aW9uSGVhZGVyIH0gZnJvbSAnLi9vdXRwdXRNZXNzYWdlcyc7XG5pbXBvcnQgeyBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0LCBnZXRDb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuXG5pbXBvcnQgc3RhcnRQcmV2aWV3U2VydmVyIGZyb20gJy4uL3ByZXZpZXctZG9jcyc7XG5cbmNvbnN0IHZhbGlkYXRlRmlsZSA9IChmaWxlUGF0aCwgb3B0aW9ucywgY21kT2JqKSA9PiB7XG4gIGxldCByZXN1bHQ7XG5cbiAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVQYXRoKSAmJiBpc0Z1bGx5UXVhbGlmaWVkVXJsKGZpbGVQYXRoKSkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdXaWxsIHZhbGlkYXRlIGZyb20gVVJMXFxuJyk7XG4gICAgcmVzdWx0ID0gdmFsaWRhdGVGcm9tVXJsKGZpbGVQYXRoLCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB2YWxpZGF0ZUZyb21GaWxlKGZpbGVQYXRoLCBvcHRpb25zKTtcbiAgfVxuICBjb25zdCByZXN1bHRTdGF0cyA9IG91dHB1dE1lc3NhZ2VzKHJlc3VsdCwgY21kT2JqKTtcbiAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgYCR7Y2hhbGsuYmx1ZUJyaWdodChmaWxlUGF0aCl9IHJlc3VsdHMuIEVycm9yczogJHtyZXN1bHRTdGF0cy50b3RhbEVycm9yc30sIHdhcm5pbmdzOiAke3Jlc3VsdFN0YXRzLnRvdGFsV2FybmluZ3N9XFxuYCxcbiAgKTtcblxuICByZXR1cm4ge1xuICAgIGVycm9yczogcmVzdWx0U3RhdHMudG90YWxFcnJvcnMsXG4gICAgd2FybmluZ3M6IHJlc3VsdFN0YXRzLnRvdGFsV2FybmluZ3MsXG4gIH07XG59O1xuXG5jb25zdCBjbGkgPSAoKSA9PiB7XG4gIGNvbnN0IGYgPSBmcy5yZWFkRmlsZVN5bmMoYCR7X19kaXJuYW1lfS8uLi9wYWNrYWdlLmpzb25gLCAndXRmLTgnKTtcbiAgY29uc3QgeyB2ZXJzaW9uIH0gPSBKU09OLnBhcnNlKGYpO1xuXG4gIHByb2dyYW1cbiAgICAudmVyc2lvbih2ZXJzaW9uLCAnLXYsIC0tdmVyc2lvbicsICdPdXRwdXQgY3VycmVudCB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIENMSS4nKTtcblxuICBwcm9ncmFtXG4gICAgLmNvbW1hbmQoJ2J1bmRsZSBbZW50cnlQb2ludHMuLi5dJylcbiAgICAuZGVzY3JpcHRpb24oJ0NyZWF0ZSBhIGJ1bmRsZSB1c2luZyA8ZW50cnlQb2ludD4gYXMgYSByb290IGRvY3VtZW50LicpXG4gICAgLm9wdGlvbignLW8sIC0tb3V0cHV0IDxvdXRwdXROYW1lPicsICdGaWxlbmFtZSBvciBmb2xkZXIgZm9yIHRoZSBidW5kbGUuJylcbiAgICAub3B0aW9uKCctLXNob3J0JywgJ1JlZHVjZSBvdXRwdXQgaW4gY2FzZSBvZiBidW5kbGluZyBlcnJvcnMuJylcbiAgICAub3B0aW9uKCctLWV4dCA8ZXh0PicsICdPdXRwdXQgZXh0ZW5zaW9uOiBqc29uLCB5YW1sIG9yIHltbCcpXG4gICAgLm9wdGlvbignLWYsIC0tZm9yY2UnLCAnUHJvZHVjZSBidW5kbGUgb3V0cHV0IGZpbGUgZXZlbiBpZiB2YWxpZGF0aW9uIGVycm9ycyB3ZXJlIGVuY291bnRlcmVkJylcbiAgICAuYWN0aW9uKChlbnRyeVBvaW50cywgY21kT2JqKSA9PiB7XG4gICAgICBpZiAoY21kT2JqLmV4dCAmJiBbJ3lhbWwnLCAneW1sJywgJ2pzb24nXS5pbmRleE9mKGNtZE9iai5leHQpID09PSAtMSkge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShcbiAgICAgICAgICAnVW5zdXBwb3J0ZWQgdmFsdWUgZm9yIC0tZXh0IG9wdGlvbi4gU3VwcG9ydGVkIHZhbHVlcyBhcmU6IHlhbWwsIHltbCBvciBqc29uJyxcbiAgICAgICAgKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjb25maWcgPSBnZXRDb25maWcoe30pO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBlbnRyeVBvaW50cyA9IGdldEZhbGxiYWNrRW50cnlQb2ludHNPckV4aXQoZW50cnlQb2ludHMsIGNvbmZpZyk7XG5cbiAgICAgIGNvbnN0IGlzT3V0cHV0RGlyID0gY21kT2JqLm91dHB1dCAmJiAhZXh0bmFtZShjbWRPYmoub3V0cHV0KTtcbiAgICAgIGNvbnN0IGV4dCA9IGNtZE9iai5leHQgfHwgZXh0bmFtZShjbWRPYmoub3V0cHV0IHx8ICcnKS5zdWJzdHJpbmcoMSkgfHwgJ3lhbWwnO1xuICAgICAgY29uc3QgZGlyID0gaXNPdXRwdXREaXIgPyBjbWRPYmoub3V0cHV0IDogZGlybmFtZShjbWRPYmoub3V0cHV0IHx8ICcnKTtcblxuICAgICAgY29uc3QgcmVzdWx0cyA9IHtcbiAgICAgICAgZXJyb3JzOiAwLFxuICAgICAgICB3YXJuaW5nczogMCxcbiAgICAgIH07XG5cbiAgICAgIGVudHJ5UG9pbnRzLmZvckVhY2goKGVudHJ5UG9pbnQpID0+IHtcbiAgICAgICAgbGV0IG91dHB1dDtcbiAgICAgICAgaWYgKGNtZE9iai5vdXRwdXQpIHtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGlzT3V0cHV0RGlyXG4gICAgICAgICAgICA/IGJhc2VuYW1lKGVudHJ5UG9pbnQsIGV4dG5hbWUoZW50cnlQb2ludCkpXG4gICAgICAgICAgICA6IGJhc2VuYW1lKGNtZE9iai5vdXRwdXQsIGAuJHtleHR9YCk7XG4gICAgICAgICAgb3V0cHV0ID0gam9pbihkaXIsIGAke2ZpbGVOYW1lfS4ke2V4dH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1bmRsaW5nU3RhdHVzID0gYnVuZGxlVG9GaWxlKGVudHJ5UG9pbnQsIG91dHB1dCwgY21kT2JqLmZvcmNlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0U3RhdHMgPSBvdXRwdXRNZXNzYWdlcyhidW5kbGluZ1N0YXR1cywgY21kT2JqKTtcblxuICAgICAgICBpZiAocmVzdWx0U3RhdHMudG90YWxFcnJvcnMgPT09IDApIHtcbiAgICAgICAgICAvLyB3ZSBkbyBub3Qgd2FudCB0byBvdXRwdXQgYW55dGhpbmcgdG8gc3Rkb3V0IGlmIGl0J3MgYmVpbmcgcGlwZWQuXG4gICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYENyZWF0ZWQgYSBidW5kbGUgZm9yICR7ZW50cnlQb2ludH0gYXQgJHtvdXRwdXR9XFxuYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjbWRPYmouZm9yY2UpIHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKFxuICAgICAgICAgICAgICBgQ3JlYXRlZCBhIGJ1bmRsZSBmb3IgJHtlbnRyeVBvaW50fSBhdCAke291dHB1dH0uIEVycm9ycyBpZ25vcmVkIGJlY2F1c2Ugb2YgLS1mb3JjZVxcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShcbiAgICAgICAgICAgICAgYEVycm9ycyBlbmNvdW50ZXJlZCB3aGlsZSBidW5kbGluZyAke2VudHJ5UG9pbnR9OiBidW5kbGUgbm90IGNyZWF0ZWQgKHVzZSAtLWZvcmNlIHRvIGlnbm9yZSBlcnJvcnMpXFxuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMuZXJyb3JzICs9IHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzO1xuICAgICAgICAgIHJlc3VsdHMud2FybmluZ3MgKz0gcmVzdWx0U3RhdHMudG90YWxXYXJuaW5ncztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwcm9jZXNzLmV4aXQocmVzdWx0cy5lcnJvcnMgPT09IDAgfHwgY21kT2JqLmZvcmNlID8gMCA6IDEpO1xuICAgIH0pO1xuXG4gIHByb2dyYW1cbiAgICAuY29tbWFuZCgndmFsaWRhdGUgW2VudHJ5UG9pbnRzLi4uXScpXG4gICAgLmRlc2NyaXB0aW9uKCdWYWxpZGF0ZSBnaXZlbiBPcGVuQVBJIDMgZGVmaW5pdGlvbiBmaWxlLicpXG4gICAgLm9wdGlvbignLS1zaG9ydCcsICdSZWR1Y2Ugb3V0cHV0IHRvIHJlcXVpcmVkIG1pbmltdW4nKVxuICAgIC5vcHRpb24oJy0tbm8tZnJhbWUnLCAnUHJpbnQgbm8gY29kZWZyYW1lcyB3aXRoIGVycm9ycy4nKVxuICAgIC5vcHRpb24oJy0tY29uZmlnIDxwYXRoPicsICdTcGVjaWZ5IGN1c3RvbSB5YW1sIG9yIGpzb24gY29uZmlnJylcbiAgICAuYWN0aW9uKChlbnRyeVBvaW50cywgY21kT2JqKSA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICBjb25zdCByZXN1bHRzID0ge1xuICAgICAgICBlcnJvcnM6IDAsXG4gICAgICAgIHdhcm5pbmdzOiAwLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgY29uZmlnID0gZ2V0Q29uZmlnKHt9KTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgZW50cnlQb2ludHMgPSBnZXRGYWxsYmFja0VudHJ5UG9pbnRzT3JFeGl0KGVudHJ5UG9pbnRzLCBjb25maWcpO1xuXG4gICAgICBvcHRpb25zLmNvZGVmcmFtZXMgPSBjbWRPYmouZnJhbWU7XG4gICAgICBpZiAoY21kT2JqLmNvbmZpZykgb3B0aW9ucy5jb25maWdQYXRoID0gY21kT2JqLmNvbmZpZztcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyeVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwcmludFZhbGlkYXRpb25IZWFkZXIoZW50cnlQb2ludHNbaV0pO1xuXG4gICAgICAgIGNvbnN0IG1zZ3MgPSB2YWxpZGF0ZUZpbGUoZW50cnlQb2ludHNbaV0sIG9wdGlvbnMsIGNtZE9iaik7XG4gICAgICAgIHJlc3VsdHMuZXJyb3JzICs9IG1zZ3MuZXJyb3JzO1xuICAgICAgICByZXN1bHRzLndhcm5pbmdzICs9IG1zZ3Mud2FybmluZ3M7XG4gICAgICB9XG4gICAgICBpZiAoZW50cnlQb2ludHMubGVuZ3RoID4gMSkge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgVG90YWwgcmVzdWx0cy4gRXJyb3JzOiAke3Jlc3VsdHMuZXJyb3JzfSwgd2FybmluZ3M6ICR7cmVzdWx0cy53YXJuaW5nc31cXG5gKTtcbiAgICAgIH1cbiAgICAgIHByb2Nlc3MuZXhpdChyZXN1bHRzLmVycm9ycyA+IDAgPyAxIDogMCk7XG4gICAgfSk7XG5cbiAgZnVuY3Rpb24gbXlQYXJzZUludCh2YWx1ZSkge1xuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICB9XG5cbiAgcHJvZ3JhbVxuICAgIC5jb21tYW5kKCdwcmV2aWV3LWRvY3MgW2VudHJ5UG9pbnRdJylcbiAgICAuZGVzY3JpcHRpb24oJ1ByZXZpZXcgQVBJIFJlZmVyZW5jZSBkb2NzIGZvciB0aGUgc3BlY2lmaWVkIGVudHJ5cG9pbnQgT0FTIGRlZmluaXRpb24nKVxuICAgIC5vcHRpb24oJy1wLCAtLXBvcnQgPHZhbHVlPicsICdQcmV2aWV3IHBvcnQnLCBteVBhcnNlSW50LCA4MDgwKVxuICAgIC5hY3Rpb24oYXN5bmMgKGVudHJ5UG9pbnQsIGNtZE9iaikgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0ID0gJ2Rpc3Qvb3BlbmFwaS55YW1sJztcblxuICAgICAgbGV0IGNvbmZpZyA9IGdldENvbmZpZyh7fSk7XG4gICAgICBpZiAoIWVudHJ5UG9pbnQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduLCBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICBlbnRyeVBvaW50ID0gZ2V0RmFsbGJhY2tFbnRyeVBvaW50c09yRXhpdChbXSwgY29uZmlnKVswXTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNhY2hlZEJ1bmRsZTtcbiAgICAgIGNvbnN0IGRlcHMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGFzeW5jIGZ1bmN0aW9uIGdldEJ1bmRsZSgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEJ1bmRsZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdXBkYXRlQnVuZGxlKCkge1xuICAgICAgICBjYWNoZWRCdW5kbGUgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXG5CdW5kbGluZy4uLlxcblxcbicpO1xuICAgICAgICAgIGNvbnN0IHsgYnVuZGxlOiBvcGVuYXBpQnVuZGxlLCByZXN1bHQsIGZpbGVEZXBlbmRlbmNpZXMgfSA9IGJ1bmRsZShlbnRyeVBvaW50LCBvdXRwdXQsIHtcbiAgICAgICAgICAgIGxpbnQ6IHtcbiAgICAgICAgICAgICAgY29kZWZyYW1lczogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IFsuLi5kZXBzXS5maWx0ZXIoKHgpID0+ICFmaWxlRGVwZW5kZW5jaWVzLmhhcyh4KSk7XG4gICAgICAgICAgd2F0Y2hlci51bndhdGNoKHJlbW92ZWQpO1xuICAgICAgICAgIHdhdGNoZXIuYWRkKFsuLi5maWxlRGVwZW5kZW5jaWVzXSk7XG4gICAgICAgICAgZGVwcy5jbGVhcigpO1xuICAgICAgICAgIGZpbGVEZXBlbmRlbmNpZXMuZm9yRWFjaChkZXBzLmFkZCwgZGVwcyk7XG5cbiAgICAgICAgICBjb25zdCByZXN1bHRTdGF0cyA9IG91dHB1dE1lc3NhZ2VzKHJlc3VsdCwgeyBzaG9ydDogdHJ1ZSB9KTtcblxuICAgICAgICAgIGlmIChyZXN1bHRTdGF0cy50b3RhbEVycm9ycyA9PT0gMCkge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXG4gICAgICAgICAgICAgIHJlc3VsdFN0YXRzLnRvdGFsRXJyb3JzID09PSAwXG4gICAgICAgICAgICAgICAgPyBgQ3JlYXRlZCBhIGJ1bmRsZSBmb3IgJHtlbnRyeVBvaW50fSAke3Jlc3VsdFN0YXRzLnRvdGFsV2FybmluZ3MgPiAwID8gJ3dpdGggd2FybmluZ3MnIDogJ3N1Y2Nlc3NmdWxseSd9XFxuYFxuICAgICAgICAgICAgICAgIDogY2hhbGsueWVsbG93KGBDcmVhdGVkIGEgYnVuZGxlIGZvciAke2VudHJ5UG9pbnR9IHdpdGggZXJyb3JzLiBEb2NzIG1heSBiZSBicm9rZW4gb3Igbm90IGFjY3VyYXRlXFxuYCksXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc29sdmUob3BlbmFwaUJ1bmRsZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdXBkYXRlQnVuZGxlKCkpOyAvLyBpbml0aWFsIGNhY2hlXG5cbiAgICAgIGNvbnN0IGhvdENsaWVudHMgPSBhd2FpdCBzdGFydFByZXZpZXdTZXJ2ZXIoY21kT2JqLnBvcnQsIHtcbiAgICAgICAgZ2V0QnVuZGxlLFxuICAgICAgICBnZXRPcHRpb25zOiAoKSA9PiBjb25maWcucmVmZXJlbmNlRG9jcyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCB3YXRjaGVyID0gY2hvY2tpZGFyLndhdGNoKFtlbnRyeVBvaW50LCBjb25maWcuY29uZmlnUGF0aF0sIHtcbiAgICAgICAgZGlzYWJsZUdsb2JiaW5nOiB0cnVlLFxuICAgICAgICBpZ25vcmVJbml0aWFsOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGRlYm91bmNlZFVwZGF0ZWRlQnVuZGxlID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgICB1cGRhdGVCdW5kbGUoKTtcbiAgICAgICAgYXdhaXQgY2FjaGVkQnVuZGxlO1xuICAgICAgICBob3RDbGllbnRzLmJyb2FkY2FzdCgne1widHlwZVwiOiBcInJlbG9hZFwiLCBcImJ1bmRsZVwiOiB0cnVlfScpO1xuICAgICAgfSwgMjAwMCk7XG5cbiAgICAgIGNvbnN0IGNoYW5nZUhhbmRsZXIgPSBhc3luYyAodHlwZSwgZmlsZSkgPT4ge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtjaGFsay5ncmVlbignd2F0Y2gnKX0gJHt0eXBlfSAke2NoYWxrLmJsdWUoZmlsZSl9XFxuYCk7XG4gICAgICAgIGlmIChmaWxlID09PSBjb25maWcuY29uZmlnUGF0aCkge1xuICAgICAgICAgIGNvbmZpZyA9IGdldENvbmZpZyh7IGNvbmZpZ1BhdGg6IGZpbGUgfSk7XG4gICAgICAgICAgaG90Q2xpZW50cy5icm9hZGNhc3QoSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAncmVsb2FkJyB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVib3VuY2VkVXBkYXRlZGVCdW5kbGUoKTtcbiAgICAgIH07XG5cbiAgICAgIHdhdGNoZXIub24oJ2NoYW5nZScsIGNoYW5nZUhhbmRsZXIuYmluZCh1bmRlZmluZWQsICdjaGFuZ2VkJykpO1xuICAgICAgd2F0Y2hlci5vbignYWRkJywgY2hhbmdlSGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgJ2FkZGVkJykpO1xuICAgICAgd2F0Y2hlci5vbigndW5saW5rJywgY2hhbmdlSGFuZGxlci5iaW5kKHVuZGVmaW5lZCwgJ3JlbW92ZWQnKSk7XG5cbiAgICAgIHdhdGNoZXIub24oJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShgXFxuICDwn5GAICBXYXRjaGluZyAke2NoYWxrLmJsdWUoZW50cnlQb2ludCl9IGFuZCBhbGwgcmVsYXRlZCByZXNvdXJjZXMgZm9yIGNoYW5nZXNcXG5gKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gIHByb2dyYW0ub24oJ2NvbW1hbmQ6KicsICgpID0+IHtcbiAgICBwcm9jZXNzLnN0ZGVyci53cml0ZShgXFxuVW5rbm93biBjb21tYW5kICR7cHJvZ3JhbS5hcmdzLmpvaW4oJyAnKX1cXG5cXG5gKTtcbiAgICBwcm9ncmFtLm91dHB1dEhlbHAoKTtcbiAgfSk7XG5cbiAgaWYgKHByb2Nlc3MuYXJndi5sZW5ndGggPT09IDIpIHByb2Nlc3MuYXJndi5wdXNoKCctaCcpO1xuXG4gIHByb2dyYW0ucGFyc2UocHJvY2Vzcy5hcmd2KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNsaTtcbiJdfQ==