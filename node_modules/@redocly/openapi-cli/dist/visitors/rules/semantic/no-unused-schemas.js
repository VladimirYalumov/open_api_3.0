"use strict";

class NoUnusedComponents {
  constructor(config) {
    this.config = config;
    this.components = {};
  }

  static get rule() {
    return 'no-unused-schemas';
  }

  OpenAPIRoot() {
    return {
      onExit: (node, definition, ctx) => {
        const messages = [];
        ctx.path.push('components');
        ctx.path.push('schemas');
        Object.keys(this.components).filter(schemaName => this.components[schemaName] === false).forEach(schemaName => {
          ctx.path.push(schemaName);
          messages.push(ctx.createError(`The schema "${schemaName}" is never used.`, 'key'));
          ctx.path.pop();
        });
        ctx.path.pop();
        ctx.path.pop();
        return messages;
      }
    };
  }

  OpenAPISchema() {
    return {
      onEnter: (node, definition, ctx, unresolvedNode) => {
        if (unresolvedNode.$ref && unresolvedNode.$ref.indexOf('#/components/schemas') === 0) {
          const schemaName = unresolvedNode.$ref.split('/')[3];

          if (Object.keys(this.components).indexOf(schemaName) !== -1) {
            this.components[schemaName] = true;
          } else {
            this.components[schemaName] = true;
          }
        }
      }
    };
  }

  OpenAPISchemaMap() {
    return {
      onEnter: (node, definition, ctx) => {
        if (ctx.path[0] === 'components' && ctx.path.length === 2 && ctx.pathStack.length === 0) {
          // in the components.schemas definition
          Object.keys(node).forEach(schemaName => {
            if (Object.keys(this.components).indexOf(schemaName) !== -1 || node[schemaName].allOf) {
              // .allOf here is used as a very naive check for possible discriminator in parent node
              this.components[schemaName] = true;
            } else {
              this.components[schemaName] = false;
            }
          });
        }
      }
    };
  }

}

module.exports = NoUnusedComponents;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy92aXNpdG9ycy9ydWxlcy9zZW1hbnRpYy9uby11bnVzZWQtc2NoZW1hcy5qcyJdLCJuYW1lcyI6WyJOb1VudXNlZENvbXBvbmVudHMiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImNvbXBvbmVudHMiLCJydWxlIiwiT3BlbkFQSVJvb3QiLCJvbkV4aXQiLCJub2RlIiwiZGVmaW5pdGlvbiIsImN0eCIsIm1lc3NhZ2VzIiwicGF0aCIsInB1c2giLCJPYmplY3QiLCJrZXlzIiwiZmlsdGVyIiwic2NoZW1hTmFtZSIsImZvckVhY2giLCJjcmVhdGVFcnJvciIsInBvcCIsIk9wZW5BUElTY2hlbWEiLCJvbkVudGVyIiwidW5yZXNvbHZlZE5vZGUiLCIkcmVmIiwiaW5kZXhPZiIsInNwbGl0IiwiT3BlbkFQSVNjaGVtYU1hcCIsImxlbmd0aCIsInBhdGhTdGFjayIsImFsbE9mIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxNQUFNQSxrQkFBTixDQUF5QjtBQUN2QkMsRUFBQUEsV0FBVyxDQUFDQyxNQUFELEVBQVM7QUFDbEIsU0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixFQUFsQjtBQUNEOztBQUVELGFBQVdDLElBQVgsR0FBa0I7QUFDaEIsV0FBTyxtQkFBUDtBQUNEOztBQUVEQyxFQUFBQSxXQUFXLEdBQUc7QUFDWixXQUFPO0FBQ0xDLE1BQUFBLE1BQU0sRUFBRSxDQUFDQyxJQUFELEVBQU9DLFVBQVAsRUFBbUJDLEdBQW5CLEtBQTJCO0FBQ2pDLGNBQU1DLFFBQVEsR0FBRyxFQUFqQjtBQUNBRCxRQUFBQSxHQUFHLENBQUNFLElBQUosQ0FBU0MsSUFBVCxDQUFjLFlBQWQ7QUFDQUgsUUFBQUEsR0FBRyxDQUFDRSxJQUFKLENBQVNDLElBQVQsQ0FBYyxTQUFkO0FBQ0FDLFFBQUFBLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLEtBQUtYLFVBQWpCLEVBQ0dZLE1BREgsQ0FDV0MsVUFBRCxJQUFnQixLQUFLYixVQUFMLENBQWdCYSxVQUFoQixNQUFnQyxLQUQxRCxFQUVHQyxPQUZILENBRVlELFVBQUQsSUFBZ0I7QUFDdkJQLFVBQUFBLEdBQUcsQ0FBQ0UsSUFBSixDQUFTQyxJQUFULENBQWNJLFVBQWQ7QUFDQU4sVUFBQUEsUUFBUSxDQUFDRSxJQUFULENBQWNILEdBQUcsQ0FBQ1MsV0FBSixDQUFpQixlQUFjRixVQUFXLGtCQUExQyxFQUE2RCxLQUE3RCxDQUFkO0FBQ0FQLFVBQUFBLEdBQUcsQ0FBQ0UsSUFBSixDQUFTUSxHQUFUO0FBQ0QsU0FOSDtBQU9BVixRQUFBQSxHQUFHLENBQUNFLElBQUosQ0FBU1EsR0FBVDtBQUNBVixRQUFBQSxHQUFHLENBQUNFLElBQUosQ0FBU1EsR0FBVDtBQUNBLGVBQU9ULFFBQVA7QUFDRDtBQWZJLEtBQVA7QUFpQkQ7O0FBRURVLEVBQUFBLGFBQWEsR0FBRztBQUNkLFdBQU87QUFDTEMsTUFBQUEsT0FBTyxFQUFFLENBQUNkLElBQUQsRUFBT0MsVUFBUCxFQUFtQkMsR0FBbkIsRUFBd0JhLGNBQXhCLEtBQTJDO0FBQ2xELFlBQUlBLGNBQWMsQ0FBQ0MsSUFBZixJQUF1QkQsY0FBYyxDQUFDQyxJQUFmLENBQW9CQyxPQUFwQixDQUE0QixzQkFBNUIsTUFBd0QsQ0FBbkYsRUFBc0Y7QUFDcEYsZ0JBQU1SLFVBQVUsR0FBR00sY0FBYyxDQUFDQyxJQUFmLENBQW9CRSxLQUFwQixDQUEwQixHQUExQixFQUErQixDQUEvQixDQUFuQjs7QUFDQSxjQUFJWixNQUFNLENBQUNDLElBQVAsQ0FBWSxLQUFLWCxVQUFqQixFQUE2QnFCLE9BQTdCLENBQXFDUixVQUFyQyxNQUFxRCxDQUFDLENBQTFELEVBQTZEO0FBQzNELGlCQUFLYixVQUFMLENBQWdCYSxVQUFoQixJQUE4QixJQUE5QjtBQUNELFdBRkQsTUFFTztBQUNMLGlCQUFLYixVQUFMLENBQWdCYSxVQUFoQixJQUE4QixJQUE5QjtBQUNEO0FBQ0Y7QUFDRjtBQVZJLEtBQVA7QUFZRDs7QUFFRFUsRUFBQUEsZ0JBQWdCLEdBQUc7QUFDakIsV0FBTztBQUNMTCxNQUFBQSxPQUFPLEVBQUUsQ0FBQ2QsSUFBRCxFQUFPQyxVQUFQLEVBQW1CQyxHQUFuQixLQUEyQjtBQUNsQyxZQUFJQSxHQUFHLENBQUNFLElBQUosQ0FBUyxDQUFULE1BQWdCLFlBQWhCLElBQWdDRixHQUFHLENBQUNFLElBQUosQ0FBU2dCLE1BQVQsS0FBb0IsQ0FBcEQsSUFBeURsQixHQUFHLENBQUNtQixTQUFKLENBQWNELE1BQWQsS0FBeUIsQ0FBdEYsRUFBeUY7QUFBRTtBQUN6RmQsVUFBQUEsTUFBTSxDQUFDQyxJQUFQLENBQVlQLElBQVosRUFBa0JVLE9BQWxCLENBQTJCRCxVQUFELElBQWdCO0FBQ3hDLGdCQUFJSCxNQUFNLENBQUNDLElBQVAsQ0FBWSxLQUFLWCxVQUFqQixFQUE2QnFCLE9BQTdCLENBQXFDUixVQUFyQyxNQUFxRCxDQUFDLENBQXRELElBQTJEVCxJQUFJLENBQUNTLFVBQUQsQ0FBSixDQUFpQmEsS0FBaEYsRUFBdUY7QUFDckY7QUFDQSxtQkFBSzFCLFVBQUwsQ0FBZ0JhLFVBQWhCLElBQThCLElBQTlCO0FBQ0QsYUFIRCxNQUdPO0FBQ0wsbUJBQUtiLFVBQUwsQ0FBZ0JhLFVBQWhCLElBQThCLEtBQTlCO0FBQ0Q7QUFDRixXQVBEO0FBUUQ7QUFDRjtBQVpJLEtBQVA7QUFjRDs7QUE1RHNCOztBQStEekJjLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQi9CLGtCQUFqQiIsInNvdXJjZXNDb250ZW50IjpbImNsYXNzIE5vVW51c2VkQ29tcG9uZW50cyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuY29tcG9uZW50cyA9IHt9O1xuICB9XG5cbiAgc3RhdGljIGdldCBydWxlKCkge1xuICAgIHJldHVybiAnbm8tdW51c2VkLXNjaGVtYXMnO1xuICB9XG5cbiAgT3BlbkFQSVJvb3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uRXhpdDogKG5vZGUsIGRlZmluaXRpb24sIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICAgICAgICBjdHgucGF0aC5wdXNoKCdjb21wb25lbnRzJyk7XG4gICAgICAgIGN0eC5wYXRoLnB1c2goJ3NjaGVtYXMnKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKVxuICAgICAgICAgIC5maWx0ZXIoKHNjaGVtYU5hbWUpID0+IHRoaXMuY29tcG9uZW50c1tzY2hlbWFOYW1lXSA9PT0gZmFsc2UpXG4gICAgICAgICAgLmZvckVhY2goKHNjaGVtYU5hbWUpID0+IHtcbiAgICAgICAgICAgIGN0eC5wYXRoLnB1c2goc2NoZW1hTmFtZSk7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGN0eC5jcmVhdGVFcnJvcihgVGhlIHNjaGVtYSBcIiR7c2NoZW1hTmFtZX1cIiBpcyBuZXZlciB1c2VkLmAsICdrZXknKSk7XG4gICAgICAgICAgICBjdHgucGF0aC5wb3AoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgY3R4LnBhdGgucG9wKCk7XG4gICAgICAgIGN0eC5wYXRoLnBvcCgpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBPcGVuQVBJU2NoZW1hKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkVudGVyOiAobm9kZSwgZGVmaW5pdGlvbiwgY3R4LCB1bnJlc29sdmVkTm9kZSkgPT4ge1xuICAgICAgICBpZiAodW5yZXNvbHZlZE5vZGUuJHJlZiAmJiB1bnJlc29sdmVkTm9kZS4kcmVmLmluZGV4T2YoJyMvY29tcG9uZW50cy9zY2hlbWFzJykgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFOYW1lID0gdW5yZXNvbHZlZE5vZGUuJHJlZi5zcGxpdCgnLycpWzNdO1xuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbXBvbmVudHMpLmluZGV4T2Yoc2NoZW1hTmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbc2NoZW1hTmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbc2NoZW1hTmFtZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgT3BlbkFQSVNjaGVtYU1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FbnRlcjogKG5vZGUsIGRlZmluaXRpb24sIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LnBhdGhbMF0gPT09ICdjb21wb25lbnRzJyAmJiBjdHgucGF0aC5sZW5ndGggPT09IDIgJiYgY3R4LnBhdGhTdGFjay5sZW5ndGggPT09IDApIHsgLy8gaW4gdGhlIGNvbXBvbmVudHMuc2NoZW1hcyBkZWZpbml0aW9uXG4gICAgICAgICAgT2JqZWN0LmtleXMobm9kZSkuZm9yRWFjaCgoc2NoZW1hTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY29tcG9uZW50cykuaW5kZXhPZihzY2hlbWFOYW1lKSAhPT0gLTEgfHwgbm9kZVtzY2hlbWFOYW1lXS5hbGxPZikge1xuICAgICAgICAgICAgICAvLyAuYWxsT2YgaGVyZSBpcyB1c2VkIGFzIGEgdmVyeSBuYWl2ZSBjaGVjayBmb3IgcG9zc2libGUgZGlzY3JpbWluYXRvciBpbiBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbc2NoZW1hTmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3NjaGVtYU5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vVW51c2VkQ29tcG9uZW50cztcbiJdfQ==