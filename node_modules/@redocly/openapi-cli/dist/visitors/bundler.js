"use strict";

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _default = require("../error/default");

var _OpenAPISchema = _interopRequireDefault(require("../types/OpenAPISchema"));

var _OpenAPIDiscriminator = require("../types/OpenAPIDiscriminator");

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-case-declarations */

/* eslint-disable no-param-reassign */

/* eslint-disable class-methods-use-this */
const getComponentName = (refString, components, componentType, node, ctx) => {
  const errors = [];
  refString = refString.replace('#/', '/');

  const itemNameBase = _path.default.basename(refString, _path.default.extname(refString));

  const pathParts = _path.default.dirname(refString).split('/');

  const componentsGroup = components[componentType];
  if (!componentsGroup) return {
    name: itemNameBase,
    errors
  };
  let name = itemNameBase;
  let i = pathParts.length - 1;

  while (componentsGroup[name] && !(0, _lodash.default)(componentsGroup[name], node) && i >= 0) {
    const prevName = name;
    name = `${pathParts[i]}_${itemNameBase}`;
    errors.push(ctx.createError(`Two schemas are referenced with the same name but different content. Renamed ${prevName} to ${name}`, 'key'));
    i--;
  }

  if (i >= 0) return {
    name,
    errors
  };
  let serialId = 0;

  while (componentsGroup[name] && !(0, _lodash.default)(componentsGroup[name], node)) {
    serialId++;
    name = `${name}-${serialId}`;
  }

  return {
    name,
    errors
  };
};

class Bundler {
  constructor(config) {
    this.config = config;
    this.nameConflictsEnabled = this.config.nameConflicts !== 'off';

    if (this.nameConflictsEnabled) {
      this.nameConflictsSeverity = (0, _default.getMsgLevelFromString)(this.config.nameConflicts || '');
    }

    this.components = {};
    this.newRefNodes = new Map();
  }

  static get rule() {
    return 'bundler';
  }

  defNameToType(definitionName) {
    switch (definitionName) {
      case 'OpenAPISchema':
        return 'schemas';

      case 'OpenAPIParameter':
        return 'parameters';

      case 'OpenAPIResponse':
        return 'responses';

      case 'OpenAPIExample':
        return 'examples';

      case 'OpenAPIRequestBody':
        return 'requestBodies';

      case 'OpenAPIHeader':
        return 'headers';

      case 'OpenAPISecuritySchema':
        return 'securitySchemes';

      case 'OpenAPILink':
        return 'links';

      case 'OpenAPICallback':
        return 'callbacks';

      default:
        return null;
    }
  }

  includeImplicitDiscriminator(pointer, schemas, ctx, {
    traverseNode,
    visited
  }) {
    const $ref = `#/${pointer.join('/')}`;
    const errors = [];

    for (const [name, schema] of Object.entries(schemas || {})) {
      if (schema.allOf && schema.allOf.find(s => s.$ref === $ref)) {
        const existingSchema = this.components.schemas && this.components.schemas[name];

        if (existingSchema && !(0, _lodash.default)(existingSchema, schema)) {
          errors.push(ctx.createError(`Implicitly mapped discriminator schema "${name}" conflicts with existing schema. Skipping.`, 'key'));
        }

        this.components.schemas = this.components.schemas || {};
        this.components.schemas[name] = schema;
        ctx.pathStack.push({
          path: ctx.path,
          file: ctx.filePath,
          document: ctx.document,
          source: ctx.source
        });
        ctx.path = ['components', 'schemas', name];
        traverseNode(schema, _OpenAPISchema.default, ctx, visited);
        ctx.path = ctx.pathStack.pop().path;
      }
    }

    return errors;
  }

  any() {
    return {
      onExit: (node, definition, ctx, unresolvedNode, {
        traverseNode,
        visited
      }) => {
        let errors = [];

        if (node.discriminator && !node.oneOf && !node.anyOf && !node.mapping) {
          errors = this.includeImplicitDiscriminator(ctx.path, ctx.document.components && ctx.document.components.schemas, ctx, {
            traverseNode,
            visited
          });
        }

        if (unresolvedNode && node !== unresolvedNode && (0, _utils.isRef)(unresolvedNode)) {
          const componentType = this.defNameToType(definition.name);

          if (!componentType) {
            delete unresolvedNode.$ref;
            Object.assign(unresolvedNode, node);
          } else if (!this.newRefNodes.has(unresolvedNode)) {
            // eslint-disable-next-line prefer-const
            const {
              name,
              errors: nameErrors
            } = getComponentName(unresolvedNode.$ref, this.components, componentType, node, ctx);
            errors.push(...nameErrors);
            const newRef = `#/components/${componentType}/${name}`;

            if (!this.components[componentType]) {
              this.components[componentType] = {};
            }

            this.components[componentType][name] = node; // we can't replace nodes in-place as non-idempotent
            // nodes will be visited again and will fail bundling
            // so we save it and replace at the end

            this.newRefNodes.set(unresolvedNode, newRef);
          }
        }

        errors.forEach(e => {
          e.severity = this.nameConflictsSeverity;
        });

        if (!this.nameConflictsEnabled) {
          errors = [];
        }

        return errors;
      }
    };
  }

  OpenAPIRoot() {
    return {
      onExit: (node, definition, ctx) => {
        if (!node.components) {
          node.components = {};
        }

        if (!this.config.ignoreErrors && ctx.result.some(e => e.severity === _default.messageLevels.ERROR)) {
          ctx.bundlingResult = null;
          return null;
        }

        for (const [unresolvedNode, newRef] of this.newRefNodes.entries()) {
          if (unresolvedNode[_OpenAPIDiscriminator.MAPPING_DATA_KEY]) {
            // FIXME: too hack
            const {
              mapping,
              key
            } = unresolvedNode[_OpenAPIDiscriminator.MAPPING_DATA_KEY];
            mapping[key] = newRef;
          } else {
            unresolvedNode.$ref = newRef;
          }
        }

        Object.keys(this.components).forEach(component => {
          node.components[component] = node.components[component] ? node.components[component] : {};
          Object.assign(node.components[component], this.components[component]);
        });
        let outputFile;

        if (this.config.output) {
          outputFile = this.config.output;
          const nameParts = outputFile.split('.');
          const ext = nameParts[nameParts.length - 1];

          const outputPath = _path.default.resolve(outputFile);

          const outputDir = _path.default.dirname(outputPath);

          _fs.default.mkdirSync(outputDir, {
            recursive: true
          });

          let fileData = null;

          switch (ext) {
            case 'json':
              fileData = JSON.stringify(node, null, 2);
              break;

            case 'yaml':
            case 'yml':
            default:
              fileData = _jsYaml.default.safeDump(node);
              break;
          }

          _fs.default.writeFileSync(`${outputPath}`, fileData);
        } else if (this.config.outputObject) {
          ctx.bundlingResult = node;
        } else {
          // default output to stdout, if smbd wants to pipe it
          process.stdout.write(_jsYaml.default.safeDump(node));
          process.stdout.write('\n');
        }

        return null;
      }
    };
  }

}

module.exports = Bundler;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy92aXNpdG9ycy9idW5kbGVyLmpzIl0sIm5hbWVzIjpbImdldENvbXBvbmVudE5hbWUiLCJyZWZTdHJpbmciLCJjb21wb25lbnRzIiwiY29tcG9uZW50VHlwZSIsIm5vZGUiLCJjdHgiLCJlcnJvcnMiLCJyZXBsYWNlIiwiaXRlbU5hbWVCYXNlIiwicGF0aCIsImJhc2VuYW1lIiwiZXh0bmFtZSIsInBhdGhQYXJ0cyIsImRpcm5hbWUiLCJzcGxpdCIsImNvbXBvbmVudHNHcm91cCIsIm5hbWUiLCJpIiwibGVuZ3RoIiwicHJldk5hbWUiLCJwdXNoIiwiY3JlYXRlRXJyb3IiLCJzZXJpYWxJZCIsIkJ1bmRsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsIm5hbWVDb25mbGljdHNFbmFibGVkIiwibmFtZUNvbmZsaWN0cyIsIm5hbWVDb25mbGljdHNTZXZlcml0eSIsIm5ld1JlZk5vZGVzIiwiTWFwIiwicnVsZSIsImRlZk5hbWVUb1R5cGUiLCJkZWZpbml0aW9uTmFtZSIsImluY2x1ZGVJbXBsaWNpdERpc2NyaW1pbmF0b3IiLCJwb2ludGVyIiwic2NoZW1hcyIsInRyYXZlcnNlTm9kZSIsInZpc2l0ZWQiLCIkcmVmIiwiam9pbiIsInNjaGVtYSIsIk9iamVjdCIsImVudHJpZXMiLCJhbGxPZiIsImZpbmQiLCJzIiwiZXhpc3RpbmdTY2hlbWEiLCJwYXRoU3RhY2siLCJmaWxlIiwiZmlsZVBhdGgiLCJkb2N1bWVudCIsInNvdXJjZSIsIk9wZW5BUElTY2hlbWFPYmplY3QiLCJwb3AiLCJhbnkiLCJvbkV4aXQiLCJkZWZpbml0aW9uIiwidW5yZXNvbHZlZE5vZGUiLCJkaXNjcmltaW5hdG9yIiwib25lT2YiLCJhbnlPZiIsIm1hcHBpbmciLCJhc3NpZ24iLCJoYXMiLCJuYW1lRXJyb3JzIiwibmV3UmVmIiwic2V0IiwiZm9yRWFjaCIsImUiLCJzZXZlcml0eSIsIk9wZW5BUElSb290IiwiaWdub3JlRXJyb3JzIiwicmVzdWx0Iiwic29tZSIsIm1lc3NhZ2VMZXZlbHMiLCJFUlJPUiIsImJ1bmRsaW5nUmVzdWx0IiwiTUFQUElOR19EQVRBX0tFWSIsImtleSIsImtleXMiLCJjb21wb25lbnQiLCJvdXRwdXRGaWxlIiwib3V0cHV0IiwibmFtZVBhcnRzIiwiZXh0Iiwib3V0cHV0UGF0aCIsInJlc29sdmUiLCJvdXRwdXREaXIiLCJmcyIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImZpbGVEYXRhIiwiSlNPTiIsInN0cmluZ2lmeSIsInlhbWwiLCJzYWZlRHVtcCIsIndyaXRlRmlsZVN5bmMiLCJvdXRwdXRPYmplY3QiLCJwcm9jZXNzIiwic3Rkb3V0Iiwid3JpdGUiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7O0FBWEE7O0FBQ0E7O0FBQ0E7QUFXQSxNQUFNQSxnQkFBZ0IsR0FBRyxDQUFDQyxTQUFELEVBQVlDLFVBQVosRUFBd0JDLGFBQXhCLEVBQXVDQyxJQUF2QyxFQUE2Q0MsR0FBN0MsS0FBcUQ7QUFDNUUsUUFBTUMsTUFBTSxHQUFHLEVBQWY7QUFFQUwsRUFBQUEsU0FBUyxHQUFHQSxTQUFTLENBQUNNLE9BQVYsQ0FBa0IsSUFBbEIsRUFBd0IsR0FBeEIsQ0FBWjs7QUFDQSxRQUFNQyxZQUFZLEdBQUdDLGNBQUtDLFFBQUwsQ0FBY1QsU0FBZCxFQUF5QlEsY0FBS0UsT0FBTCxDQUFhVixTQUFiLENBQXpCLENBQXJCOztBQUNBLFFBQU1XLFNBQVMsR0FBR0gsY0FBS0ksT0FBTCxDQUFhWixTQUFiLEVBQXdCYSxLQUF4QixDQUE4QixHQUE5QixDQUFsQjs7QUFFQSxRQUFNQyxlQUFlLEdBQUdiLFVBQVUsQ0FBQ0MsYUFBRCxDQUFsQztBQUNBLE1BQUksQ0FBQ1ksZUFBTCxFQUFzQixPQUFPO0FBQUVDLElBQUFBLElBQUksRUFBRVIsWUFBUjtBQUFzQkYsSUFBQUE7QUFBdEIsR0FBUDtBQUV0QixNQUFJVSxJQUFJLEdBQUdSLFlBQVg7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QWM1RixJQUFkLENBQXJCO0FBQ0ErRixVQUFBQSxPQUFPLENBQUNDLE1BQVIsQ0FBZUMsS0FBZixDQUFxQixJQUFyQjtBQUNEOztBQUNELGVBQU8sSUFBUDtBQUNEO0FBMURJLEtBQVA7QUE0REQ7O0FBN0xXOztBQWdNZEMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCaEYsT0FBakIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qIGVzbGludC1kaXNhYmxlIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMgKi9cbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGlzRXF1YWwgZnJvbSAnbG9kYXNoLmlzZXF1YWwnO1xuXG5pbXBvcnQgeyBnZXRNc2dMZXZlbEZyb21TdHJpbmcsIG1lc3NhZ2VMZXZlbHMgfSBmcm9tICcuLi9lcnJvci9kZWZhdWx0JztcbmltcG9ydCBPcGVuQVBJU2NoZW1hT2JqZWN0IGZyb20gJy4uL3R5cGVzL09wZW5BUElTY2hlbWEnO1xuaW1wb3J0IHsgTUFQUElOR19EQVRBX0tFWSB9IGZyb20gJy4uL3R5cGVzL09wZW5BUElEaXNjcmltaW5hdG9yJztcbmltcG9ydCB7IGlzUmVmIH0gZnJvbSAnLi4vdXRpbHMnO1xuXG5jb25zdCBnZXRDb21wb25lbnROYW1lID0gKHJlZlN0cmluZywgY29tcG9uZW50cywgY29tcG9uZW50VHlwZSwgbm9kZSwgY3R4KSA9PiB7XG4gIGNvbnN0IGVycm9ycyA9IFtdO1xuXG4gIHJlZlN0cmluZyA9IHJlZlN0cmluZy5yZXBsYWNlKCcjLycsICcvJyk7XG4gIGNvbnN0IGl0ZW1OYW1lQmFzZSA9IHBhdGguYmFzZW5hbWUocmVmU3RyaW5nLCBwYXRoLmV4dG5hbWUocmVmU3RyaW5nKSk7XG4gIGNvbnN0IHBhdGhQYXJ0cyA9IHBhdGguZGlybmFtZShyZWZTdHJpbmcpLnNwbGl0KCcvJyk7XG5cbiAgY29uc3QgY29tcG9uZW50c0dyb3VwID0gY29tcG9uZW50c1tjb21wb25lbnRUeXBlXTtcbiAgaWYgKCFjb21wb25lbnRzR3JvdXApIHJldHVybiB7IG5hbWU6IGl0ZW1OYW1lQmFzZSwgZXJyb3JzIH07XG5cbiAgbGV0IG5hbWUgPSBpdGVtTmFtZUJhc2U7XG4gIGxldCBpID0gcGF0aFBhcnRzLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGNvbXBvbmVudHNHcm91cFtuYW1lXSAmJiAhaXNFcXVhbChjb21wb25lbnRzR3JvdXBbbmFtZV0sIG5vZGUpICYmIGkgPj0gMCkge1xuICAgIGNvbnN0IHByZXZOYW1lID0gbmFtZTtcbiAgICBuYW1lID0gYCR7cGF0aFBhcnRzW2ldfV8ke2l0ZW1OYW1lQmFzZX1gO1xuXG4gICAgZXJyb3JzLnB1c2goXG4gICAgICBjdHguY3JlYXRlRXJyb3IoXG4gICAgICAgIGBUd28gc2NoZW1hcyBhcmUgcmVmZXJlbmNlZCB3aXRoIHRoZSBzYW1lIG5hbWUgYnV0IGRpZmZlcmVudCBjb250ZW50LiBSZW5hbWVkICR7cHJldk5hbWV9IHRvICR7bmFtZX1gLFxuICAgICAgICAna2V5JyxcbiAgICAgICksXG4gICAgKTtcbiAgICBpLS07XG4gIH1cblxuICBpZiAoaSA+PSAwKSByZXR1cm4geyBuYW1lLCBlcnJvcnMgfTtcblxuICBsZXQgc2VyaWFsSWQgPSAwO1xuICB3aGlsZSAoY29tcG9uZW50c0dyb3VwW25hbWVdICYmICFpc0VxdWFsKGNvbXBvbmVudHNHcm91cFtuYW1lXSwgbm9kZSkpIHtcbiAgICBzZXJpYWxJZCsrO1xuICAgIG5hbWUgPSBgJHtuYW1lfS0ke3NlcmlhbElkfWA7XG4gIH1cblxuICByZXR1cm4geyBuYW1lLCBlcnJvcnMgfTtcbn07XG5cbmNsYXNzIEJ1bmRsZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICB0aGlzLm5hbWVDb25mbGljdHNFbmFibGVkID0gdGhpcy5jb25maWcubmFtZUNvbmZsaWN0cyAhPT0gJ29mZic7XG4gICAgaWYgKHRoaXMubmFtZUNvbmZsaWN0c0VuYWJsZWQpIHtcbiAgICAgIHRoaXMubmFtZUNvbmZsaWN0c1NldmVyaXR5ID0gZ2V0TXNnTGV2ZWxGcm9tU3RyaW5nKHRoaXMuY29uZmlnLm5hbWVDb25mbGljdHMgfHwgJycpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcblxuICAgIHRoaXMubmV3UmVmTm9kZXMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHJ1bGUoKSB7XG4gICAgcmV0dXJuICdidW5kbGVyJztcbiAgfVxuXG4gIGRlZk5hbWVUb1R5cGUoZGVmaW5pdGlvbk5hbWUpIHtcbiAgICBzd2l0Y2ggKGRlZmluaXRpb25OYW1lKSB7XG4gICAgICBjYXNlICdPcGVuQVBJU2NoZW1hJzpcbiAgICAgICAgcmV0dXJuICdzY2hlbWFzJztcbiAgICAgIGNhc2UgJ09wZW5BUElQYXJhbWV0ZXInOlxuICAgICAgICByZXR1cm4gJ3BhcmFtZXRlcnMnO1xuICAgICAgY2FzZSAnT3BlbkFQSVJlc3BvbnNlJzpcbiAgICAgICAgcmV0dXJuICdyZXNwb25zZXMnO1xuICAgICAgY2FzZSAnT3BlbkFQSUV4YW1wbGUnOlxuICAgICAgICByZXR1cm4gJ2V4YW1wbGVzJztcbiAgICAgIGNhc2UgJ09wZW5BUElSZXF1ZXN0Qm9keSc6XG4gICAgICAgIHJldHVybiAncmVxdWVzdEJvZGllcyc7XG4gICAgICBjYXNlICdPcGVuQVBJSGVhZGVyJzpcbiAgICAgICAgcmV0dXJuICdoZWFkZXJzJztcbiAgICAgIGNhc2UgJ09wZW5BUElTZWN1cml0eVNjaGVtYSc6XG4gICAgICAgIHJldHVybiAnc2VjdXJpdHlTY2hlbWVzJztcbiAgICAgIGNhc2UgJ09wZW5BUElMaW5rJzpcbiAgICAgICAgcmV0dXJuICdsaW5rcyc7XG4gICAgICBjYXNlICdPcGVuQVBJQ2FsbGJhY2snOlxuICAgICAgICByZXR1cm4gJ2NhbGxiYWNrcyc7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpbmNsdWRlSW1wbGljaXREaXNjcmltaW5hdG9yKHBvaW50ZXIsIHNjaGVtYXMsIGN0eCwgeyB0cmF2ZXJzZU5vZGUsIHZpc2l0ZWQgfSkge1xuICAgIGNvbnN0ICRyZWYgPSBgIy8ke3BvaW50ZXIuam9pbignLycpfWA7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBzY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYXMgfHwge30pKSB7XG4gICAgICBpZiAoc2NoZW1hLmFsbE9mICYmIHNjaGVtYS5hbGxPZi5maW5kKChzKSA9PiBzLiRyZWYgPT09ICRyZWYpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU2NoZW1hID0gdGhpcy5jb21wb25lbnRzLnNjaGVtYXMgJiYgdGhpcy5jb21wb25lbnRzLnNjaGVtYXNbbmFtZV07XG4gICAgICAgIGlmIChleGlzdGluZ1NjaGVtYSAmJiAhaXNFcXVhbChleGlzdGluZ1NjaGVtYSwgc2NoZW1hKSkge1xuICAgICAgICAgIGVycm9ycy5wdXNoKGN0eC5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIGBJbXBsaWNpdGx5IG1hcHBlZCBkaXNjcmltaW5hdG9yIHNjaGVtYSBcIiR7bmFtZX1cIiBjb25mbGljdHMgd2l0aCBleGlzdGluZyBzY2hlbWEuIFNraXBwaW5nLmAsICdrZXknLFxuICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNjaGVtYXMgPSB0aGlzLmNvbXBvbmVudHMuc2NoZW1hcyB8fCB7fTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNjaGVtYXNbbmFtZV0gPSBzY2hlbWE7XG5cbiAgICAgICAgY3R4LnBhdGhTdGFjay5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBmaWxlOiBjdHguZmlsZVBhdGgsXG4gICAgICAgICAgZG9jdW1lbnQ6IGN0eC5kb2N1bWVudCxcbiAgICAgICAgICBzb3VyY2U6IGN0eC5zb3VyY2UsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGN0eC5wYXRoID0gWydjb21wb25lbnRzJywgJ3NjaGVtYXMnLCBuYW1lXTtcbiAgICAgICAgdHJhdmVyc2VOb2RlKHNjaGVtYSwgT3BlbkFQSVNjaGVtYU9iamVjdCwgY3R4LCB2aXNpdGVkKTtcbiAgICAgICAgY3R4LnBhdGggPSBjdHgucGF0aFN0YWNrLnBvcCgpLnBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVycm9ycztcbiAgfVxuXG4gIGFueSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb25FeGl0OiAobm9kZSwgZGVmaW5pdGlvbiwgY3R4LCB1bnJlc29sdmVkTm9kZSwgeyB0cmF2ZXJzZU5vZGUsIHZpc2l0ZWQgfSkgPT4ge1xuICAgICAgICBsZXQgZXJyb3JzID0gW107XG5cbiAgICAgICAgaWYgKG5vZGUuZGlzY3JpbWluYXRvciAmJiAhbm9kZS5vbmVPZiAmJiAhbm9kZS5hbnlPZiAmJiAhbm9kZS5tYXBwaW5nKSB7XG4gICAgICAgICAgZXJyb3JzID0gdGhpcy5pbmNsdWRlSW1wbGljaXREaXNjcmltaW5hdG9yKFxuICAgICAgICAgICAgY3R4LnBhdGgsXG4gICAgICAgICAgICBjdHguZG9jdW1lbnQuY29tcG9uZW50cyAmJiBjdHguZG9jdW1lbnQuY29tcG9uZW50cy5zY2hlbWFzLFxuICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgeyB0cmF2ZXJzZU5vZGUsIHZpc2l0ZWQgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVucmVzb2x2ZWROb2RlICYmIG5vZGUgIT09IHVucmVzb2x2ZWROb2RlICYmIGlzUmVmKHVucmVzb2x2ZWROb2RlKSkge1xuICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFR5cGUgPSB0aGlzLmRlZk5hbWVUb1R5cGUoZGVmaW5pdGlvbi5uYW1lKTtcblxuICAgICAgICAgIGlmICghY29tcG9uZW50VHlwZSkge1xuICAgICAgICAgICAgZGVsZXRlIHVucmVzb2x2ZWROb2RlLiRyZWY7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHVucmVzb2x2ZWROb2RlLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm5ld1JlZk5vZGVzLmhhcyh1bnJlc29sdmVkTm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZSwgZXJyb3JzOiBuYW1lRXJyb3JzIH0gPSBnZXRDb21wb25lbnROYW1lKFxuICAgICAgICAgICAgICB1bnJlc29sdmVkTm9kZS4kcmVmLCB0aGlzLmNvbXBvbmVudHMsIGNvbXBvbmVudFR5cGUsIG5vZGUsIGN0eCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLm5hbWVFcnJvcnMpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdSZWYgPSBgIy9jb21wb25lbnRzLyR7Y29tcG9uZW50VHlwZX0vJHtuYW1lfWA7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wb25lbnRzW2NvbXBvbmVudFR5cGVdKSB7XG4gICAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tjb21wb25lbnRUeXBlXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50VHlwZV1bbmFtZV0gPSBub2RlO1xuICAgICAgICAgICAgLy8gd2UgY2FuJ3QgcmVwbGFjZSBub2RlcyBpbi1wbGFjZSBhcyBub24taWRlbXBvdGVudFxuICAgICAgICAgICAgLy8gbm9kZXMgd2lsbCBiZSB2aXNpdGVkIGFnYWluIGFuZCB3aWxsIGZhaWwgYnVuZGxpbmdcbiAgICAgICAgICAgIC8vIHNvIHdlIHNhdmUgaXQgYW5kIHJlcGxhY2UgYXQgdGhlIGVuZFxuICAgICAgICAgICAgdGhpcy5uZXdSZWZOb2Rlcy5zZXQodW5yZXNvbHZlZE5vZGUsIG5ld1JlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXJyb3JzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICBlLnNldmVyaXR5ID0gdGhpcy5uYW1lQ29uZmxpY3RzU2V2ZXJpdHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdGhpcy5uYW1lQ29uZmxpY3RzRW5hYmxlZCkge1xuICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9ycztcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIE9wZW5BUElSb290KCkge1xuICAgIHJldHVybiB7XG4gICAgICBvbkV4aXQ6IChub2RlLCBkZWZpbml0aW9uLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuaWdub3JlRXJyb3JzICYmIGN0eC5yZXN1bHQuc29tZSgoZSkgPT4gZS5zZXZlcml0eSA9PT0gbWVzc2FnZUxldmVscy5FUlJPUikpIHtcbiAgICAgICAgICBjdHguYnVuZGxpbmdSZXN1bHQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBbdW5yZXNvbHZlZE5vZGUsIG5ld1JlZl0gb2YgdGhpcy5uZXdSZWZOb2Rlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAodW5yZXNvbHZlZE5vZGVbTUFQUElOR19EQVRBX0tFWV0pIHsgLy8gRklYTUU6IHRvbyBoYWNrXG4gICAgICAgICAgICBjb25zdCB7IG1hcHBpbmcsIGtleSB9ID0gdW5yZXNvbHZlZE5vZGVbTUFQUElOR19EQVRBX0tFWV07XG4gICAgICAgICAgICBtYXBwaW5nW2tleV0gPSBuZXdSZWY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVucmVzb2x2ZWROb2RlLiRyZWYgPSBuZXdSZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb21wb25lbnRzKS5mb3JFYWNoKChjb21wb25lbnQpID0+IHtcbiAgICAgICAgICBub2RlLmNvbXBvbmVudHNbY29tcG9uZW50XSA9IG5vZGUuY29tcG9uZW50c1tjb21wb25lbnRdID8gbm9kZS5jb21wb25lbnRzW2NvbXBvbmVudF0gOiB7fTtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKG5vZGUuY29tcG9uZW50c1tjb21wb25lbnRdLCB0aGlzLmNvbXBvbmVudHNbY29tcG9uZW50XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBvdXRwdXRGaWxlO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5vdXRwdXQpIHtcbiAgICAgICAgICBvdXRwdXRGaWxlID0gdGhpcy5jb25maWcub3V0cHV0O1xuICAgICAgICAgIGNvbnN0IG5hbWVQYXJ0cyA9IG91dHB1dEZpbGUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBjb25zdCBleHQgPSBuYW1lUGFydHNbbmFtZVBhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgY29uc3Qgb3V0cHV0UGF0aCA9IHBhdGgucmVzb2x2ZShvdXRwdXRGaWxlKTtcblxuICAgICAgICAgIGNvbnN0IG91dHB1dERpciA9IHBhdGguZGlybmFtZShvdXRwdXRQYXRoKTtcbiAgICAgICAgICBmcy5ta2RpclN5bmMob3V0cHV0RGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICAgICAgICAgIGxldCBmaWxlRGF0YSA9IG51bGw7XG5cbiAgICAgICAgICBzd2l0Y2ggKGV4dCkge1xuICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgIGZpbGVEYXRhID0gSlNPTi5zdHJpbmdpZnkobm9kZSwgbnVsbCwgMik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneWFtbCc6XG4gICAgICAgICAgICBjYXNlICd5bWwnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgZmlsZURhdGEgPSB5YW1sLnNhZmVEdW1wKG5vZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnMud3JpdGVGaWxlU3luYyhgJHtvdXRwdXRQYXRofWAsIGZpbGVEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbmZpZy5vdXRwdXRPYmplY3QpIHtcbiAgICAgICAgICBjdHguYnVuZGxpbmdSZXN1bHQgPSBub2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRlZmF1bHQgb3V0cHV0IHRvIHN0ZG91dCwgaWYgc21iZCB3YW50cyB0byBwaXBlIGl0XG4gICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoeWFtbC5zYWZlRHVtcChub2RlKSk7XG4gICAgICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQnVuZGxlcjtcbiJdfQ==