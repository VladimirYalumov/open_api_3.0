"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popPath = popPath;
exports.resolveNodeNoSideEffects = resolveNodeNoSideEffects;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _path = require("path");

var _url = require("url");

var _xmlhttprequest = require("xmlhttprequest");

var _error = _interopRequireWildcard(require("./error"));

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pushPath(ctx, filePath, docPath) {
  ctx.pathStack.push({
    path: ctx.path,
    file: ctx.filePath,
    document: ctx.document,
    source: ctx.source
  });
  ctx.path = docPath;
  ctx.filePath = filePath;
}

function popPath(ctx) {
  const topPath = ctx.pathStack.pop();
  ctx.path = topPath.path;
  ctx.filePath = topPath.file;
  ctx.source = topPath.source;
  ctx.document = topPath.document;
}
/**
 *
 * Here we go over each of the steps in the link and try to retreive the value
 * for it. If failed (e.g. because of undefined value) -- return null, to indicate that such
 * reference does not exist.
 *
 * TODO: we might need a feature to support validation of "URL" based definitions in the future, so
 * would be nice to have opportunity to call resolve() with empty ctx.
 *
 * TODO: add per-file/per-url cache
 *
 * @param {string} link A path in the yaml document which is to be resolved
 * @param {*} ctx JSON Object with the document field which represents the YAML structure
 */


function resolve(link, ctx, visited = []) {
  const linkSplitted = link.split('#/');
  if (linkSplitted[0] === '') linkSplitted[0] = ctx.filePath;
  const [filePath, docPath] = linkSplitted;
  const resolvedFilePath = (0, _utils.isFullyQualifiedUrl)(ctx.filePath) || (0, _utils.isFullyQualifiedUrl)(filePath) ? (0, _url.resolve)(ctx.filePath, filePath) : (0, _path.resolve)((0, _path.dirname)(ctx.filePath), filePath);
  let document;
  let source;
  const isCurrentDocument = resolvedFilePath === ctx.filePath;
  pushPath(ctx, resolvedFilePath, []);
  const resolvedLink = `${resolvedFilePath}#/${docPath}`;

  if (!isCurrentDocument) {
    if (ctx.resolveCache[resolvedFilePath]) {
      ({
        source,
        document
      } = ctx.resolveCache[resolvedFilePath]);
    } else if (_fs.default.existsSync(resolvedFilePath)) {
      ctx.fileDependencies.add(resolvedFilePath); // FIXME: if refernced e.g. md file, no need to parse

      source = _fs.default.readFileSync(resolvedFilePath, 'utf-8');

      try {
        document = _jsYaml.default.safeLoad(source);
      } catch (e) {
        ctx.result.push((0, _error.createYAMLParseError)(e, ctx, resolvedFilePath));
        return {
          node: undefined
        };
      } // FIXME: lost yaml parsing and file read errors here

    } else if ((0, _utils.isFullyQualifiedUrl)(resolvedFilePath)) {
      try {
        const xhr = new _xmlhttprequest.XMLHttpRequest();
        xhr.open('GET', resolvedFilePath, false);
        xhr.send();

        if (xhr.status !== 200) {
          return {
            node: undefined
          };
        }

        source = xhr.responseText;
        document = _jsYaml.default.safeLoad(source);
      } catch (e) {
        // FIXME: lost yaml parsing errors and network errors here
        return {
          node: undefined
        };
      }
    } else {
      return {
        node: undefined
      };
    }
  } else {
    document = ctx.document;
    source = ctx.source;
  }

  if (source) ctx.resolveCache[resolvedFilePath] = {
    source,
    document
  };
  ctx.source = source;
  ctx.document = document;
  const docPathSteps = docPath ? docPath.split('/').filter(el => el !== '').reverse() : [];
  let target = document;
  let circular;
  let transitiveResolvesOnStack = 0;
  let transitiveError;

  if (visited.indexOf(resolvedLink) > -1) {
    target = undefined;
    circular = true;
  }

  visited.push(resolvedLink);

  while (target !== undefined) {
    if (target && target.$ref) {
      // handle transitive $ref's
      const resolved = resolve(target.$ref, ctx, visited);
      transitiveError = resolved.transitiveError;

      if (resolved.node === undefined && !transitiveError) {
        // We want to show only the error for the first $ref that can't be resolved.
        // So we create it on the current stack and propagate it out as a transitiveError
        popPath(ctx);
        ctx.path.push('$ref');
        const message = resolved.circular ? 'Circular reference.' : 'Reference does not exist.';
        transitiveError = (0, _error.default)(message, target, ctx, {
          fromRule: 'resolve-ref'
        });
        ctx.path.pop();
        target = undefined;
        break;
      }

      target = resolved.node;
      transitiveResolvesOnStack++;
    }

    const step = docPathSteps.pop();
    if (!step) break;
    target = target && target[step] !== undefined ? target[step] : undefined;
    ctx.path.push(step);
  }

  for (let i = 0; i < transitiveResolvesOnStack; ++i) {
    // keep current file context and remove indirection records
    ctx.pathStack.pop();
  }

  if (transitiveError) {
    // recalc referencedFrom after exiting transitive ref stack to show original $ref in the error
    transitiveError.referencedFrom = (0, _error.getReferencedFrom)(ctx);
  }

  return {
    node: target,
    transitiveError,
    circular
  };
}
/*
 * This function is used to resolve $ref fields inside the node. Currently supports links:
 * - inside the file
 * - to the another file in local file system
 * - http(s) links to other files
 *
 * $ref field value must be a valid OpenAPI link
 * (e.g. another/dir/file.yaml#/components/schemas/Example)
 *
 * @param {*} node
 * @param {*} ctx
 */


function resolveNode(node, ctx) {
  if (!node || typeof node !== 'object') return {
    node
  };

  if (node.$ref) {
    const resolved = resolve(node.$ref, ctx);

    if (resolved.node === undefined) {
      // can't resolve
      popPath(ctx);
      ctx.path.push('$ref');
      const error = resolved.transitiveError ? resolved.transitiveError : (0, _error.default)('Reference does not exist.', node, ctx, {
        fromRule: 'resolve-ref'
      });
      ctx.path.pop();
      ctx.result.push(error);
      return {
        node
      };
    }

    return {
      node: resolved.node,
      onStack: true
    };
  }

  return {
    node
  };
} // to be used in mutators


function resolveNodeNoSideEffects(node, ctx) {
  const ctxCopy = { ...ctx,
    pathStack: ctx.pathStack.slice()
  };
  return resolveNode(node, ctxCopy);
}

var _default = resolveNode;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNvbHZlci5qcyJdLCJuYW1lcyI6WyJwdXNoUGF0aCIsImN0eCIsImZpbGVQYXRoIiwiZG9jUGF0aCIsInBhdGhTdGFjayIsInB1c2giLCJwYXRoIiwiZmlsZSIsImRvY3VtZW50Iiwic291cmNlIiwicG9wUGF0aCIsInRvcFBhdGgiLCJwb3AiLCJyZXNvbHZlIiwibGluayIsInZpc2l0ZWQiLCJsaW5rU3BsaXR0ZWQiLCJzcGxpdCIsInJlc29sdmVkRmlsZVBhdGgiLCJpc0N1cnJlbnREb2N1bWVudCIsInJlc29sdmVkTGluayIsInJlc29sdmVDYWNoZSIsImZzIiwiZXhpc3RzU3luYyIsImZpbGVEZXBlbmRlbmNpZXMiLCJhZGQiLCJyZWFkRmlsZVN5bmMiLCJ5YW1sIiwic2FmZUxvYWQiLCJlIiwicmVzdWx0Iiwibm9kZSIsInVuZGVmaW5lZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJkb2NQYXRoU3RlcHMiLCJmaWx0ZXIiLCJlbCIsInJldmVyc2UiLCJ0YXJnZXQiLCJjaXJjdWxhciIsInRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2siLCJ0cmFuc2l0aXZlRXJyb3IiLCJpbmRleE9mIiwiJHJlZiIsInJlc29sdmVkIiwibWVzc2FnZSIsImZyb21SdWxlIiwic3RlcCIsImkiLCJyZWZlcmVuY2VkRnJvbSIsInJlc29sdmVOb2RlIiwiZXJyb3IiLCJvblN0YWNrIiwicmVzb2x2ZU5vZGVOb1NpZGVFZmZlY3RzIiwiY3R4Q29weSIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF1QkMsUUFBdkIsRUFBaUNDLE9BQWpDLEVBQTBDO0FBQ3hDRixFQUFBQSxHQUFHLENBQUNHLFNBQUosQ0FBY0MsSUFBZCxDQUFtQjtBQUNq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SSxDQUFDaUIsSUFBTixFQUFZL0MsR0FBWixDQUF4Qjs7QUFDQSxRQUFJZ0QsUUFBUSxDQUFDbEIsSUFBVCxLQUFrQkMsU0FBdEIsRUFBaUM7QUFBRTtBQUNqQ3RCLE1BQUFBLE9BQU8sQ0FBQ1QsR0FBRCxDQUFQO0FBRUFBLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTRCxJQUFULENBQWMsTUFBZDtBQUNBLFlBQU1tRCxLQUFLLEdBQUdQLFFBQVEsQ0FBQ0gsZUFBVCxHQUNWRyxRQUFRLENBQUNILGVBREMsR0FFVixvQkFBWSwyQkFBWixFQUF5Q2YsSUFBekMsRUFBK0M5QixHQUEvQyxFQUFvRDtBQUFFa0QsUUFBQUEsUUFBUSxFQUFFO0FBQVosT0FBcEQsQ0FGSjtBQUdBbEQsTUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVNNLEdBQVQ7QUFFQVgsTUFBQUEsR0FBRyxDQUFDNkIsTUFBSixDQUFXekIsSUFBWCxDQUFnQm1ELEtBQWhCO0FBRUEsYUFBTztBQUFFekIsUUFBQUE7QUFBRixPQUFQO0FBQ0Q7O0FBRUQsV0FBTztBQUFFQSxNQUFBQSxJQUFJLEVBQUVrQixRQUFRLENBQUNsQixJQUFqQjtBQUF1QjBCLE1BQUFBLE9BQU8sRUFBRTtBQUFoQyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTztBQUFFMUIsSUFBQUE7QUFBRixHQUFQO0FBQ0QsQyxDQUVEOzs7QUFDTyxTQUFTMkIsd0JBQVQsQ0FBa0MzQixJQUFsQyxFQUF3QzlCLEdBQXhDLEVBQTZDO0FBQ2xELFFBQU0wRCxPQUFPLEdBQUcsRUFBRSxHQUFHMUQsR0FBTDtBQUFVRyxJQUFBQSxTQUFTLEVBQUVILEdBQUcsQ0FBQ0csU0FBSixDQUFjd0QsS0FBZDtBQUFyQixHQUFoQjtBQUNBLFNBQU9MLFdBQVcsQ0FBQ3hCLElBQUQsRUFBTzRCLE9BQVAsQ0FBbEI7QUFDRDs7ZUFFY0osVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlRmlsZSwgZGlybmFtZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlVXJsIH0gZnJvbSAndXJsJztcbmltcG9ydCB7IFhNTEh0dHBSZXF1ZXN0IH0gZnJvbSAneG1saHR0cHJlcXVlc3QnO1xuXG5pbXBvcnQgY3JlYXRlRXJyb3IsIHsgZ2V0UmVmZXJlbmNlZEZyb20sIGNyZWF0ZVlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBpc0Z1bGx5UXVhbGlmaWVkVXJsIH0gZnJvbSAnLi91dGlscyc7XG5cbmZ1bmN0aW9uIHB1c2hQYXRoKGN0eCwgZmlsZVBhdGgsIGRvY1BhdGgpIHtcbiAgY3R4LnBhdGhTdGFjay5wdXNoKHtcbiAgICBwYXRoOiBjdHgucGF0aCwgZmlsZTogY3R4LmZpbGVQYXRoLCBkb2N1bWVudDogY3R4LmRvY3VtZW50LCBzb3VyY2U6IGN0eC5zb3VyY2UsXG4gIH0pO1xuXG4gIGN0eC5wYXRoID0gZG9jUGF0aDtcbiAgY3R4LmZpbGVQYXRoID0gZmlsZVBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BQYXRoKGN0eCkge1xuICBjb25zdCB0b3BQYXRoID0gY3R4LnBhdGhTdGFjay5wb3AoKTtcbiAgY3R4LnBhdGggPSB0b3BQYXRoLnBhdGg7XG4gIGN0eC5maWxlUGF0aCA9IHRvcFBhdGguZmlsZTtcbiAgY3R4LnNvdXJjZSA9IHRvcFBhdGguc291cmNlO1xuICBjdHguZG9jdW1lbnQgPSB0b3BQYXRoLmRvY3VtZW50O1xufVxuXG4vKipcbiAqXG4gKiBIZXJlIHdlIGdvIG92ZXIgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhlIGxpbmsgYW5kIHRyeSB0byByZXRyZWl2ZSB0aGUgdmFsdWVcbiAqIGZvciBpdC4gSWYgZmFpbGVkIChlLmcuIGJlY2F1c2Ugb2YgdW5kZWZpbmVkIHZhbHVlKSAtLSByZXR1cm4gbnVsbCwgdG8gaW5kaWNhdGUgdGhhdCBzdWNoXG4gKiByZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuXG4gKlxuICogVE9ETzogd2UgbWlnaHQgbmVlZCBhIGZlYXR1cmUgdG8gc3VwcG9ydCB2YWxpZGF0aW9uIG9mIFwiVVJMXCIgYmFzZWQgZGVmaW5pdGlvbnMgaW4gdGhlIGZ1dHVyZSwgc29cbiAqIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBvcHBvcnR1bml0eSB0byBjYWxsIHJlc29sdmUoKSB3aXRoIGVtcHR5IGN0eC5cbiAqXG4gKiBUT0RPOiBhZGQgcGVyLWZpbGUvcGVyLXVybCBjYWNoZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIEEgcGF0aCBpbiB0aGUgeWFtbCBkb2N1bWVudCB3aGljaCBpcyB0byBiZSByZXNvbHZlZFxuICogQHBhcmFtIHsqfSBjdHggSlNPTiBPYmplY3Qgd2l0aCB0aGUgZG9jdW1lbnQgZmllbGQgd2hpY2ggcmVwcmVzZW50cyB0aGUgWUFNTCBzdHJ1Y3R1cmVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShsaW5rLCBjdHgsIHZpc2l0ZWQgPSBbXSkge1xuICBjb25zdCBsaW5rU3BsaXR0ZWQgPSBsaW5rLnNwbGl0KCcjLycpO1xuICBpZiAobGlua1NwbGl0dGVkWzBdID09PSAnJykgbGlua1NwbGl0dGVkWzBdID0gY3R4LmZpbGVQYXRoO1xuICBjb25zdCBbZmlsZVBhdGgsIGRvY1BhdGhdID0gbGlua1NwbGl0dGVkO1xuXG4gIGNvbnN0IHJlc29sdmVkRmlsZVBhdGggPSAoaXNGdWxseVF1YWxpZmllZFVybChjdHguZmlsZVBhdGgpIHx8IGlzRnVsbHlRdWFsaWZpZWRVcmwoZmlsZVBhdGgpKVxuICAgID8gcmVzb2x2ZVVybChjdHguZmlsZVBhdGgsIGZpbGVQYXRoKVxuICAgIDogcmVzb2x2ZUZpbGUoZGlybmFtZShjdHguZmlsZVBhdGgpLCBmaWxlUGF0aCk7XG5cbiAgbGV0IGRvY3VtZW50O1xuICBsZXQgc291cmNlO1xuXG4gIGNvbnN0IGlzQ3VycmVudERvY3VtZW50ID0gcmVzb2x2ZWRGaWxlUGF0aCA9PT0gY3R4LmZpbGVQYXRoO1xuXG4gIHB1c2hQYXRoKGN0eCwgcmVzb2x2ZWRGaWxlUGF0aCwgW10pO1xuXG4gIGNvbnN0IHJlc29sdmVkTGluayA9IGAke3Jlc29sdmVkRmlsZVBhdGh9Iy8ke2RvY1BhdGh9YDtcblxuICBpZiAoIWlzQ3VycmVudERvY3VtZW50KSB7XG4gICAgaWYgKGN0eC5yZXNvbHZlQ2FjaGVbcmVzb2x2ZWRGaWxlUGF0aF0pIHtcbiAgICAgICh7IHNvdXJjZSwgZG9jdW1lbnQgfSA9IGN0eC5yZXNvbHZlQ2FjaGVbcmVzb2x2ZWRGaWxlUGF0aF0pO1xuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhyZXNvbHZlZEZpbGVQYXRoKSkge1xuICAgICAgY3R4LmZpbGVEZXBlbmRlbmNpZXMuYWRkKHJlc29sdmVkRmlsZVBhdGgpO1xuICAgICAgLy8gRklYTUU6IGlmIHJlZmVybmNlZCBlLmcuIG1kIGZpbGUsIG5vIG5lZWQgdG8gcGFyc2VcbiAgICAgIHNvdXJjZSA9IGZzLnJlYWRGaWxlU3luYyhyZXNvbHZlZEZpbGVQYXRoLCAndXRmLTgnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50ID0geWFtbC5zYWZlTG9hZChzb3VyY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjdHgucmVzdWx0LnB1c2goY3JlYXRlWUFNTFBhcnNlRXJyb3IoZSwgY3R4LCByZXNvbHZlZEZpbGVQYXRoKSk7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IGxvc3QgeWFtbCBwYXJzaW5nIGFuZCBmaWxlIHJlYWQgZXJyb3JzIGhlcmVcbiAgICB9IGVsc2UgaWYgKGlzRnVsbHlRdWFsaWZpZWRVcmwocmVzb2x2ZWRGaWxlUGF0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgcmVzb2x2ZWRGaWxlUGF0aCwgZmFsc2UpO1xuICAgICAgICB4aHIuc2VuZCgpO1xuXG4gICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4geyBub2RlOiB1bmRlZmluZWQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvdXJjZSA9IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGRvY3VtZW50ID0geWFtbC5zYWZlTG9hZChzb3VyY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBGSVhNRTogbG9zdCB5YW1sIHBhcnNpbmcgZXJyb3JzIGFuZCBuZXR3b3JrIGVycm9ycyBoZXJlXG4gICAgICAgIHJldHVybiB7IG5vZGU6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBub2RlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9jdW1lbnQgPSBjdHguZG9jdW1lbnQ7XG4gICAgc291cmNlID0gY3R4LnNvdXJjZTtcbiAgfVxuXG4gIGlmIChzb3VyY2UpIGN0eC5yZXNvbHZlQ2FjaGVbcmVzb2x2ZWRGaWxlUGF0aF0gPSB7IHNvdXJjZSwgZG9jdW1lbnQgfTtcblxuICBjdHguc291cmNlID0gc291cmNlO1xuICBjdHguZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICBjb25zdCBkb2NQYXRoU3RlcHMgPSBkb2NQYXRoID8gZG9jUGF0aC5zcGxpdCgnLycpLmZpbHRlcigoZWwpID0+IGVsICE9PSAnJykucmV2ZXJzZSgpIDogW107XG5cbiAgbGV0IHRhcmdldCA9IGRvY3VtZW50O1xuICBsZXQgY2lyY3VsYXI7XG4gIGxldCB0cmFuc2l0aXZlUmVzb2x2ZXNPblN0YWNrID0gMDtcbiAgbGV0IHRyYW5zaXRpdmVFcnJvcjtcblxuICBpZiAodmlzaXRlZC5pbmRleE9mKHJlc29sdmVkTGluaykgPiAtMSkge1xuICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICBjaXJjdWxhciA9IHRydWU7XG4gIH1cblxuICB2aXNpdGVkLnB1c2gocmVzb2x2ZWRMaW5rKTtcblxuICB3aGlsZSAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC4kcmVmKSB7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGl2ZSAkcmVmJ3NcbiAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZSh0YXJnZXQuJHJlZiwgY3R4LCB2aXNpdGVkKTtcbiAgICAgIHRyYW5zaXRpdmVFcnJvciA9IHJlc29sdmVkLnRyYW5zaXRpdmVFcnJvcjtcbiAgICAgIGlmIChyZXNvbHZlZC5ub2RlID09PSB1bmRlZmluZWQgJiYgIXRyYW5zaXRpdmVFcnJvcikge1xuICAgICAgICAvLyBXZSB3YW50IHRvIHNob3cgb25seSB0aGUgZXJyb3IgZm9yIHRoZSBmaXJzdCAkcmVmIHRoYXQgY2FuJ3QgYmUgcmVzb2x2ZWQuXG4gICAgICAgIC8vIFNvIHdlIGNyZWF0ZSBpdCBvbiB0aGUgY3VycmVudCBzdGFjayBhbmQgcHJvcGFnYXRlIGl0IG91dCBhcyBhIHRyYW5zaXRpdmVFcnJvclxuICAgICAgICBwb3BQYXRoKGN0eCk7XG4gICAgICAgIGN0eC5wYXRoLnB1c2goJyRyZWYnKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc29sdmVkLmNpcmN1bGFyID8gJ0NpcmN1bGFyIHJlZmVyZW5jZS4nIDogJ1JlZmVyZW5jZSBkb2VzIG5vdCBleGlzdC4nO1xuICAgICAgICB0cmFuc2l0aXZlRXJyb3IgPSBjcmVhdGVFcnJvcihtZXNzYWdlLCB0YXJnZXQsIGN0eCwgeyBmcm9tUnVsZTogJ3Jlc29sdmUtcmVmJyB9KTtcbiAgICAgICAgY3R4LnBhdGgucG9wKCk7XG4gICAgICAgIHRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0YXJnZXQgPSByZXNvbHZlZC5ub2RlO1xuICAgICAgdHJhbnNpdGl2ZVJlc29sdmVzT25TdGFjaysrO1xuICAgIH1cblxuICAgIGNvbnN0IHN0ZXAgPSBkb2NQYXRoU3RlcHMucG9wKCk7XG4gICAgaWYgKCFzdGVwKSBicmVhaztcblxuICAgIHRhcmdldCA9IHRhcmdldCAmJiB0YXJnZXRbc3RlcF0gIT09IHVuZGVmaW5lZCA/IHRhcmdldFtzdGVwXSA6IHVuZGVmaW5lZDtcbiAgICBjdHgucGF0aC5wdXNoKHN0ZXApO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2l0aXZlUmVzb2x2ZXNPblN0YWNrOyArK2kpIHtcbiAgICAvLyBrZWVwIGN1cnJlbnQgZmlsZSBjb250ZXh0IGFuZCByZW1vdmUgaW5kaXJlY3Rpb24gcmVjb3Jkc1xuICAgIGN0eC5wYXRoU3RhY2sucG9wKCk7XG4gIH1cblxuICBpZiAodHJhbnNpdGl2ZUVycm9yKSB7XG4gICAgLy8gcmVjYWxjIHJlZmVyZW5jZWRGcm9tIGFmdGVyIGV4aXRpbmcgdHJhbnNpdGl2ZSByZWYgc3RhY2sgdG8gc2hvdyBvcmlnaW5hbCAkcmVmIGluIHRoZSBlcnJvclxuICAgIHRyYW5zaXRpdmVFcnJvci5yZWZlcmVuY2VkRnJvbSA9IGdldFJlZmVyZW5jZWRGcm9tKGN0eCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG5vZGU6IHRhcmdldCxcbiAgICB0cmFuc2l0aXZlRXJyb3IsXG4gICAgY2lyY3VsYXIsXG4gIH07XG59XG5cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXNvbHZlICRyZWYgZmllbGRzIGluc2lkZSB0aGUgbm9kZS4gQ3VycmVudGx5IHN1cHBvcnRzIGxpbmtzOlxuICogLSBpbnNpZGUgdGhlIGZpbGVcbiAqIC0gdG8gdGhlIGFub3RoZXIgZmlsZSBpbiBsb2NhbCBmaWxlIHN5c3RlbVxuICogLSBodHRwKHMpIGxpbmtzIHRvIG90aGVyIGZpbGVzXG4gKlxuICogJHJlZiBmaWVsZCB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgT3BlbkFQSSBsaW5rXG4gKiAoZS5nLiBhbm90aGVyL2Rpci9maWxlLnlhbWwjL2NvbXBvbmVudHMvc2NoZW1hcy9FeGFtcGxlKVxuICpcbiAqIEBwYXJhbSB7Kn0gbm9kZVxuICogQHBhcmFtIHsqfSBjdHhcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZU5vZGUobm9kZSwgY3R4KSB7XG4gIGlmICghbm9kZSB8fCB0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHJldHVybiB7IG5vZGUgfTtcblxuICBpZiAobm9kZS4kcmVmKSB7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlKG5vZGUuJHJlZiwgY3R4KTtcbiAgICBpZiAocmVzb2x2ZWQubm9kZSA9PT0gdW5kZWZpbmVkKSB7IC8vIGNhbid0IHJlc29sdmVcbiAgICAgIHBvcFBhdGgoY3R4KTtcblxuICAgICAgY3R4LnBhdGgucHVzaCgnJHJlZicpO1xuICAgICAgY29uc3QgZXJyb3IgPSByZXNvbHZlZC50cmFuc2l0aXZlRXJyb3JcbiAgICAgICAgPyByZXNvbHZlZC50cmFuc2l0aXZlRXJyb3JcbiAgICAgICAgOiBjcmVhdGVFcnJvcignUmVmZXJlbmNlIGRvZXMgbm90IGV4aXN0LicsIG5vZGUsIGN0eCwgeyBmcm9tUnVsZTogJ3Jlc29sdmUtcmVmJyB9KTtcbiAgICAgIGN0eC5wYXRoLnBvcCgpO1xuXG4gICAgICBjdHgucmVzdWx0LnB1c2goZXJyb3IpO1xuXG4gICAgICByZXR1cm4geyBub2RlIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbm9kZTogcmVzb2x2ZWQubm9kZSwgb25TdGFjazogdHJ1ZSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgbm9kZSB9O1xufVxuXG4vLyB0byBiZSB1c2VkIGluIG11dGF0b3JzXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZU5vZGVOb1NpZGVFZmZlY3RzKG5vZGUsIGN0eCkge1xuICBjb25zdCBjdHhDb3B5ID0geyAuLi5jdHgsIHBhdGhTdGFjazogY3R4LnBhdGhTdGFjay5zbGljZSgpIH07XG4gIHJldHVybiByZXNvbHZlTm9kZShub2RlLCBjdHhDb3B5KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZU5vZGU7XG4iXX0=