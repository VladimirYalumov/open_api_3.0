"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.getCodeFrameForLocation = exports.getLocationByPath = void 0;

var _yamlAstParser = require("yaml-ast-parser");

var _utils = require("../utils");

const astCache = {};

const parseAST = ({
  filePath,
  source
}) => {
  if (!astCache[filePath]) {
    astCache[filePath] = (0, _yamlAstParser.safeLoad)(source);
  }

  return astCache[filePath];
};

const getMappingChild = (mapping, childName) => {
  const mappings = mapping.value ? mapping.value.mappings : mapping.mappings;
  const target = mappings.filter(child => child.key.value === childName);
  return target ? target[0] : null;
};

const getSequenceElement = (seq, id) => seq.value ? seq.value.items[id] : seq.items[id];

const getNodeByPath = (tree, path, target = 'value') => {
  if (path.length === 0) {
    return target === 'key' && tree.key ? tree.key : tree;
  }

  const nextKey = path.pop();
  let next;

  if (tree.value && tree.value.mappings || tree.mappings) {
    next = getMappingChild(tree, nextKey);
  } else if (tree.value && tree.value.items || tree.items) {
    next = getSequenceElement(tree, nextKey);
  }

  if (!next) return target === 'key' && tree.key ? tree.key : tree;
  return getNodeByPath(next, path, target);
};

const endOfFirstLine = text => {
  let i = 0;

  while (text[i] !== '\n' && i <= text.length) i += 1;

  return i;
};

const getLocationByPath = (path, {
  filePath,
  source
}, target) => {
  const AST = parseAST({
    filePath,
    source
  });
  const node = getNodeByPath(AST, path.reverse(), target); // TODO: regression test
  // if (!node) {
  //   return null;
  // }

  const frame = source.substring(node.startPosition, node.endPosition + 1);
  const offset = frame.length - frame.trimRight().length;
  let endIndex = node.endPosition;
  const positionStart = (0, _utils.getLineNumberFromId)(source, node.startPosition);
  const endPosition = (0, _utils.getLineNumberFromId)(source, node.endPosition - offset); // we need this peace of code for case when the found code frame is the whole
  // document.
  // in such case, we want to output just the first line of it.
  // refactoring would be appreciated here.

  if (node.startPosition === 0 && node.endPosition === source.length) {
    endPosition.lineNum = positionStart.lineNum;
    endPosition.posNum = endOfFirstLine(source);
    endIndex = endOfFirstLine(source);
  }

  return {
    startLine: positionStart.lineNum,
    startCol: positionStart.posNum,
    endLine: endPosition.lineNum,
    endCol: endPosition.posNum,
    startIndex: node.startPosition,
    endIndex
  };
};

exports.getLocationByPath = getLocationByPath;

const getCodeFrameForLocation = ( // FIXME: we should not requre 'startLine' parameter, as it can be calculated implicitly
// using 'start' parameter
start, end, source, startLine = 1, linesBefore = 3, linesAfter = 2) => {
  let frameStart = start;
  let frameEnd = end;
  let actualLinesBefore = 0;
  let actualLinesAfter = 0;

  while (actualLinesBefore !== linesBefore && frameStart >= 0) {
    if (source[frameStart - 1] === '\n') actualLinesBefore += 1;
    frameStart -= 1;
  } // fixme: fix this hardcode +1/+2, also what about windows-style endings


  const codeFrameEndsLine = source[end] === '\n' || source[end + 1] === '\n' || source[end + 2] === '\n'; // we need this complex condition, so that if the end of codeframe
  // doesn't belong to the end of line
  // we considered it and added additional line to the codeframe

  while ((codeFrameEndsLine && actualLinesAfter !== linesAfter || !codeFrameEndsLine && actualLinesAfter - 1 !== linesAfter) && frameEnd < source.length) {
    if (source[frameEnd + 2] === '\n') actualLinesAfter += 1;
    frameEnd += 1;
  }

  const codeFrame = source.substring(frameStart, frameEnd + 1);
  let startOffset = start - frameStart;
  let endOffset = startOffset + end - start;
  if (frameStart === -1) startOffset -= 1;
  if (frameStart === -1) endOffset -= 1;
  const codeFrameStart = codeFrame.substring(0, startOffset);
  const codeFrameEnd = codeFrame.substring(endOffset);
  const codeFrameMain = (0, _utils.outputUnderline)((0, _utils.outputRed)(codeFrame.substring(startOffset, endOffset)));
  let codeFrameString = `${codeFrameStart}${codeFrameMain}${codeFrameEnd}`;
  const fromStart = start === 0;
  const lines = !fromStart ? codeFrameString.split('\n').slice(1) : codeFrameString.split('\n');
  const maxLineNum = lines.length + startLine; // Here we do deindenting. First of: find how much spaces there are before the line start,
  // and then -- deindent as much as we can.

  let minSpaces = lines.reduce((acc, val) => val.length > acc ? val.length : acc, 0);
  lines.forEach(line => {
    let spaces;

    for (spaces = 0; line[spaces] === ' ' && spaces < line.length; spaces += 1);

    if (minSpaces > spaces) minSpaces = spaces;
  });
  lines.forEach((_, id) => {
    const lineNum = String(`0${startLine - actualLinesBefore + id + (fromStart ? 0 : 1)}`).slice(-maxLineNum.toString().length);
    const line = minSpaces >= 8 ? lines[id].slice(minSpaces) : lines[id];

    if (id <= actualLinesBefore - 1 || id > lines.length - actualLinesAfter - 1) {
      lines[id] = (0, _utils.outputGrey)(`${lineNum}| ${line}`);
    } else {
      lines[id] = `${(0, _utils.outputGrey)(`${lineNum}|`)}${(0, _utils.outputRed)(` ${line}`)}`;
    }
  });
  codeFrameString = lines.join('\n');
  return codeFrameString;
};

exports.getCodeFrameForLocation = getCodeFrameForLocation;
var _default = getLocationByPath;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy95YW1sL2luZGV4LmpzIl0sIm5hbWVzIjpbImFzdENhY2hlIiwicGFyc2VBU1QiLCJmaWxlUGF0aCIsInNvdXJjZSIsImdldE1hcHBpbmdDaGlsZCIsIm1hcHBpbmciLCJjaGlsZE5hbWUiLCJtYXBwaW5ncyIsInZhbHVlIiwidGFyZ2V0IiwiZmlsdGVyIiwiY2hpbGQiLCJrZXkiLCJnZXRTZXF1ZW5jZUVsZW1lbnQiLCJzZXEiLCJpZCIsIml0ZW1zIiwiZ2V0Tm9kZUJ5UGF0aCIsInRyZWUiLCJwYXRoIiwibGVuZ3RoIiwibmV4dEtleSIsInBvcCIsIm5leHQiLCJlbmRPZkZpcnN0TGluZSIsInRleHQiLCJpIiwiZ2V0TG9jYXRpb25CeVBhdGgiLCJBU1QiLCJub2RlIiwicmV2ZXJzZSIsImZyYW1lIiwic3Vic3RyaW5nIiwic3RhcnRQb3NpdGlvbiIsImVuZFBvc2l0aW9uIiwib2Zmc2V0IiwidHJpbVJpZ2h0IiwiZW5kSW5kZXgiLCJwb3NpdGlvblN0YXJ0IiwibGluZU51bSIsInBvc051bSIsInN0YXJ0TGluZSIsInN0YXJ0Q29sIiwiZW5kTGluZSIsImVuZENvbCIsInN0YXJ0SW5kZXgiLCJnZXRDb2RlRnJhbWVGb3JMb2NhdGlvbiIsInN0YXJ0IiwiZW5kIiwibGluZXNCZWZvcmUiLCJsaW5lc0FmdGVyIiwiZnJhbWVTdGFydCIsImZyYW1lRW5kIiwiYWN0dWFsTGluZXNCZWZvcmUiLCJhY3R1YWxMaW5lc0FmdGVyIiwiY29kZUZyYW1lRW5kc0xpbmUiLCJjb2RlRnJhbWUiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImNvZGVGcmFtZVN0YXJ0IiwiY29kZUZyYW1lRW5kIiwiY29kZUZyYW1lTWFpbiIsImNvZGVGcmFtZVN0cmluZyIsImZyb21TdGFydCIsImxpbmVzIiwic3BsaXQiLCJzbGljZSIsIm1heExpbmVOdW0iLCJtaW5TcGFjZXMiLCJyZWR1Y2UiLCJhY2MiLCJ2YWwiLCJmb3JFYWNoIiwibGluZSIsInNwYWNlcyIs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LEtBQUssQ0FBQ2pELEVBQUQsQ0FBaEU7O0FBQ0EsUUFBSUEsRUFBRSxJQUFJc0MsaUJBQWlCLEdBQUcsQ0FBMUIsSUFBK0J0QyxFQUFFLEdBQUdpRCxLQUFLLENBQUM1QyxNQUFOLEdBQWVrQyxnQkFBZixHQUFrQyxDQUExRSxFQUE2RTtBQUMzRVUsTUFBQUEsS0FBSyxDQUFDakQsRUFBRCxDQUFMLEdBQVksdUJBQVksR0FBRXdCLE9BQVEsS0FBSWtDLElBQUssRUFBL0IsQ0FBWjtBQUNELEtBRkQsTUFFTztBQUNMVCxNQUFBQSxLQUFLLENBQUNqRCxFQUFELENBQUwsR0FBYSxHQUFFLHVCQUFZLEdBQUV3QixPQUFRLEdBQXRCLENBQTBCLEdBQUUsc0JBQVcsSUFBR2tDLElBQUssRUFBbkIsQ0FBc0IsRUFBakU7QUFDRDtBQUNGLEdBUkQ7QUFVQVgsRUFBQUEsZUFBZSxHQUFHRSxLQUFLLENBQUNjLElBQU4sQ0FBVyxJQUFYLENBQWxCO0FBRUEsU0FBT2hCLGVBQVA7QUFDRCxDQXRFTTs7O2VBd0VRbkMsaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzYWZlTG9hZCB9IGZyb20gJ3lhbWwtYXN0LXBhcnNlcic7XG5cbmltcG9ydCB7XG4gIG91dHB1dFJlZCwgb3V0cHV0VW5kZXJsaW5lLCBnZXRMaW5lTnVtYmVyRnJvbUlkLCBvdXRwdXRHcmV5LFxufSBmcm9tICcuLi91dGlscyc7XG5cbmNvbnN0IGFzdENhY2hlID0ge307XG5cbmNvbnN0IHBhcnNlQVNUID0gKHsgZmlsZVBhdGgsIHNvdXJjZSB9KSA9PiB7XG4gIGlmICghYXN0Q2FjaGVbZmlsZVBhdGhdKSB7XG4gICAgYXN0Q2FjaGVbZmlsZVBhdGhdID0gc2FmZUxvYWQoc291cmNlKTtcbiAgfVxuICByZXR1cm4gYXN0Q2FjaGVbZmlsZVBhdGhdO1xufTtcblxuY29uc3QgZ2V0TWFwcGluZ0NoaWxkID0gKG1hcHBpbmcsIGNoaWxkTmFtZSkgPT4ge1xuICBjb25zdCBtYXBwaW5ncyA9IG1hcHBpbmcudmFsdWUgPyBtYXBwaW5nLnZhbHVlLm1hcHBpbmdzIDogbWFwcGluZy5tYXBwaW5ncztcbiAgY29uc3QgdGFyZ2V0ID0gbWFwcGluZ3NcbiAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQua2V5LnZhbHVlID09PSBjaGlsZE5hbWUpO1xuICByZXR1cm4gdGFyZ2V0ID8gdGFyZ2V0WzBdIDogbnVsbDtcbn07XG5cbmNvbnN0IGdldFNlcXVlbmNlRWxlbWVudCA9IChzZXEsIGlkKSA9PiAoc2VxLnZhbHVlID8gc2VxLnZhbHVlLml0ZW1zW2lkXSA6IHNlcS5pdGVtc1tpZF0pO1xuXG5jb25zdCBnZXROb2RlQnlQYXRoID0gKHRyZWUsIHBhdGgsIHRhcmdldCA9ICd2YWx1ZScpID0+IHtcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRhcmdldCA9PT0gJ2tleScgJiYgdHJlZS5rZXkgPyB0cmVlLmtleSA6IHRyZWU7XG4gIH1cbiAgY29uc3QgbmV4dEtleSA9IHBhdGgucG9wKCk7XG5cbiAgbGV0IG5leHQ7XG4gIGlmICgodHJlZS52YWx1ZSAmJiB0cmVlLnZhbHVlLm1hcHBpbmdzKSB8fCB0cmVlLm1hcHBpbmdzKSB7XG4gICAgbmV4dCA9IGdldE1hcHBpbmdDaGlsZCh0cmVlLCBuZXh0S2V5KTtcbiAgfSBlbHNlIGlmICgodHJlZS52YWx1ZSAmJiB0cmVlLnZhbHVlLml0ZW1zKSB8fCB0cmVlLml0ZW1zKSB7XG4gICAgbmV4dCA9IGdldFNlcXVlbmNlRWxlbWVudCh0cmVlLCBuZXh0S2V5KTtcbiAgfVxuXG4gIGlmICghbmV4dCkgcmV0dXJuIHRhcmdldCA9PT0gJ2tleScgJiYgdHJlZS5rZXkgPyB0cmVlLmtleSA6IHRyZWU7XG4gIHJldHVybiBnZXROb2RlQnlQYXRoKG5leHQsIHBhdGgsIHRhcmdldCk7XG59O1xuXG5jb25zdCBlbmRPZkZpcnN0TGluZSA9ICh0ZXh0KSA9PiB7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKHRleHRbaV0gIT09ICdcXG4nICYmIGkgPD0gdGV4dC5sZW5ndGgpIGkgKz0gMTtcbiAgcmV0dXJuIGk7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0TG9jYXRpb25CeVBhdGggPSAocGF0aCwgeyBmaWxlUGF0aCwgc291cmNlIH0sIHRhcmdldCkgPT4ge1xuICBjb25zdCBBU1QgPSBwYXJzZUFTVCh7IGZpbGVQYXRoLCBzb3VyY2UgfSk7XG4gIGNvbnN0IG5vZGUgPSBnZXROb2RlQnlQYXRoKEFTVCwgcGF0aC5yZXZlcnNlKCksIHRhcmdldCk7XG4gIC8vIFRPRE86IHJlZ3Jlc3Npb24gdGVzdFxuICAvLyBpZiAoIW5vZGUpIHtcbiAgLy8gICByZXR1cm4gbnVsbDtcbiAgLy8gfVxuXG4gIGNvbnN0IGZyYW1lID0gc291cmNlLnN1YnN0cmluZyhub2RlLnN0YXJ0UG9zaXRpb24sIG5vZGUuZW5kUG9zaXRpb24gKyAxKTtcbiAgY29uc3Qgb2Zmc2V0ID0gZnJhbWUubGVuZ3RoIC0gZnJhbWUudHJpbVJpZ2h0KCkubGVuZ3RoO1xuXG4gIGxldCBlbmRJbmRleCA9IG5vZGUuZW5kUG9zaXRpb247XG4gIGNvbnN0IHBvc2l0aW9uU3RhcnQgPSBnZXRMaW5lTnVtYmVyRnJvbUlkKHNvdXJjZSwgbm9kZS5zdGFydFBvc2l0aW9uKTtcbiAgY29uc3QgZW5kUG9zaXRpb24gPSBnZXRMaW5lTnVtYmVyRnJvbUlkKHNvdXJjZSwgbm9kZS5lbmRQb3NpdGlvbiAtIG9mZnNldCk7XG5cbiAgLy8gd2UgbmVlZCB0aGlzIHBlYWNlIG9mIGNvZGUgZm9yIGNhc2Ugd2hlbiB0aGUgZm91bmQgY29kZSBmcmFtZSBpcyB0aGUgd2hvbGVcbiAgLy8gZG9jdW1lbnQuXG4gIC8vIGluIHN1Y2ggY2FzZSwgd2Ugd2FudCB0byBvdXRwdXQganVzdCB0aGUgZmlyc3QgbGluZSBvZiBpdC5cbiAgLy8gcmVmYWN0b3Jpbmcgd291bGQgYmUgYXBwcmVjaWF0ZWQgaGVyZS5cbiAgaWYgKG5vZGUuc3RhcnRQb3NpdGlvbiA9PT0gMCAmJiBub2RlLmVuZFBvc2l0aW9uID09PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgZW5kUG9zaXRpb24ubGluZU51bSA9IHBvc2l0aW9uU3RhcnQubGluZU51bTtcbiAgICBlbmRQb3NpdGlvbi5wb3NOdW0gPSBlbmRPZkZpcnN0TGluZShzb3VyY2UpO1xuICAgIGVuZEluZGV4ID0gZW5kT2ZGaXJzdExpbmUoc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnRMaW5lOiBwb3NpdGlvblN0YXJ0LmxpbmVOdW0sXG4gICAgc3RhcnRDb2w6IHBvc2l0aW9uU3RhcnQucG9zTnVtLFxuICAgIGVuZExpbmU6IGVuZFBvc2l0aW9uLmxpbmVOdW0sXG4gICAgZW5kQ29sOiBlbmRQb3NpdGlvbi5wb3NOdW0sXG4gICAgc3RhcnRJbmRleDogbm9kZS5zdGFydFBvc2l0aW9uLFxuICAgIGVuZEluZGV4LFxuICB9O1xufTtcblxuZXhwb3J0IGNvbnN0IGdldENvZGVGcmFtZUZvckxvY2F0aW9uID0gKFxuICAvLyBGSVhNRTogd2Ugc2hvdWxkIG5vdCByZXF1cmUgJ3N0YXJ0TGluZScgcGFyYW1ldGVyLCBhcyBpdCBjYW4gYmUgY2FsY3VsYXRlZCBpbXBsaWNpdGx5XG4gIC8vIHVzaW5nICdzdGFydCcgcGFyYW1ldGVyXG4gIHN0YXJ0LCBlbmQsIHNvdXJjZSwgc3RhcnRMaW5lID0gMSwgbGluZXNCZWZvcmUgPSAzLCBsaW5lc0FmdGVyID0gMixcbikgPT4ge1xuICBsZXQgZnJhbWVTdGFydCA9IHN0YXJ0O1xuICBsZXQgZnJhbWVFbmQgPSBlbmQ7XG4gIGxldCBhY3R1YWxMaW5lc0JlZm9yZSA9IDA7XG4gIGxldCBhY3R1YWxMaW5lc0FmdGVyID0gMDtcblxuICB3aGlsZSAoYWN0dWFsTGluZXNCZWZvcmUgIT09IGxpbmVzQmVmb3JlICYmIGZyYW1lU3RhcnQgPj0gMCkge1xuICAgIGlmIChzb3VyY2VbZnJhbWVTdGFydCAtIDFdID09PSAnXFxuJykgYWN0dWFsTGluZXNCZWZvcmUgKz0gMTtcbiAgICBmcmFtZVN0YXJ0IC09IDE7XG4gIH1cblxuICAvLyBmaXhtZTogZml4IHRoaXMgaGFyZGNvZGUgKzEvKzIsIGFsc28gd2hhdCBhYm91dCB3aW5kb3dzLXN0eWxlIGVuZGluZ3NcbiAgY29uc3QgY29kZUZyYW1lRW5kc0xpbmUgPSBzb3VyY2VbZW5kXSA9PT0gJ1xcbicgfHwgc291cmNlW2VuZCArIDFdID09PSAnXFxuJyB8fCBzb3VyY2VbZW5kICsgMl0gPT09ICdcXG4nO1xuXG4gIC8vIHdlIG5lZWQgdGhpcyBjb21wbGV4IGNvbmRpdGlvbiwgc28gdGhhdCBpZiB0aGUgZW5kIG9mIGNvZGVmcmFtZVxuICAvLyBkb2Vzbid0IGJlbG9uZyB0byB0aGUgZW5kIG9mIGxpbmVcbiAgLy8gd2UgY29uc2lkZXJlZCBpdCBhbmQgYWRkZWQgYWRkaXRpb25hbCBsaW5lIHRvIHRoZSBjb2RlZnJhbWVcbiAgd2hpbGUgKChcbiAgICAoY29kZUZyYW1lRW5kc0xpbmUgJiYgYWN0dWFsTGluZXNBZnRlciAhPT0gbGluZXNBZnRlcilcbiAgICB8fCAoIWNvZGVGcmFtZUVuZHNMaW5lICYmIGFjdHVhbExpbmVzQWZ0ZXIgLSAxICE9PSBsaW5lc0FmdGVyKVxuICApICYmIGZyYW1lRW5kIDwgc291cmNlLmxlbmd0aCkge1xuICAgIGlmIChzb3VyY2VbZnJhbWVFbmQgKyAyXSA9PT0gJ1xcbicpIGFjdHVhbExpbmVzQWZ0ZXIgKz0gMTtcbiAgICBmcmFtZUVuZCArPSAxO1xuICB9XG5cbiAgY29uc3QgY29kZUZyYW1lID0gc291cmNlLnN1YnN0cmluZyhmcmFtZVN0YXJ0LCBmcmFtZUVuZCArIDEpO1xuICBsZXQgc3RhcnRPZmZzZXQgPSBzdGFydCAtIGZyYW1lU3RhcnQ7XG4gIGxldCBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIGVuZCAtIHN0YXJ0O1xuXG4gIGlmIChmcmFtZVN0YXJ0ID09PSAtMSkgc3RhcnRPZmZzZXQgLT0gMTtcbiAgaWYgKGZyYW1lU3RhcnQgPT09IC0xKSBlbmRPZmZzZXQgLT0gMTtcblxuICBjb25zdCBjb2RlRnJhbWVTdGFydCA9IGNvZGVGcmFtZS5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpO1xuICBjb25zdCBjb2RlRnJhbWVFbmQgPSBjb2RlRnJhbWUuc3Vic3RyaW5nKGVuZE9mZnNldCk7XG4gIGNvbnN0IGNvZGVGcmFtZU1haW4gPSBvdXRwdXRVbmRlcmxpbmUob3V0cHV0UmVkKGNvZGVGcmFtZS5zdWJzdHJpbmcoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkpKTtcbiAgbGV0IGNvZGVGcmFtZVN0cmluZyA9IGAke2NvZGVGcmFtZVN0YXJ0fSR7Y29kZUZyYW1lTWFpbn0ke2NvZGVGcmFtZUVuZH1gO1xuXG4gIGNvbnN0IGZyb21TdGFydCA9IHN0YXJ0ID09PSAwO1xuICBjb25zdCBsaW5lcyA9ICFmcm9tU3RhcnQgPyBjb2RlRnJhbWVTdHJpbmcuc3BsaXQoJ1xcbicpLnNsaWNlKDEpIDogY29kZUZyYW1lU3RyaW5nLnNwbGl0KCdcXG4nKTtcbiAgY29uc3QgbWF4TGluZU51bSA9IGxpbmVzLmxlbmd0aCArIHN0YXJ0TGluZTtcblxuXG4gIC8vIEhlcmUgd2UgZG8gZGVpbmRlbnRpbmcuIEZpcnN0IG9mOiBmaW5kIGhvdyBtdWNoIHNwYWNlcyB0aGVyZSBhcmUgYmVmb3JlIHRoZSBsaW5lIHN0YXJ0LFxuICAvLyBhbmQgdGhlbiAtLSBkZWluZGVudCBhcyBtdWNoIGFzIHdlIGNhbi5cblxuICBsZXQgbWluU3BhY2VzID0gbGluZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gKHZhbC5sZW5ndGggPiBhY2MgPyB2YWwubGVuZ3RoIDogYWNjKSwgMCk7XG5cbiAgbGluZXMuZm9yRWFjaCgobGluZSkgPT4ge1xuICAgIGxldCBzcGFjZXM7XG4gICAgZm9yIChzcGFjZXMgPSAwOyBsaW5lW3NwYWNlc10gPT09ICcgJyAmJiBzcGFjZXMgPCBsaW5lLmxlbmd0aDsgc3BhY2VzICs9IDEpO1xuICAgIGlmIChtaW5TcGFjZXMgPiBzcGFjZXMpIG1pblNwYWNlcyA9IHNwYWNlcztcbiAgfSk7XG5cbiAgbGluZXMuZm9yRWFjaCgoXywgaWQpID0+IHtcbiAgICBjb25zdCBsaW5lTnVtID0gU3RyaW5nKGAwJHtzdGFydExpbmUgLSBhY3R1YWxMaW5lc0JlZm9yZSArIGlkICsgKGZyb21TdGFydCA/IDAgOiAxKX1gKS5zbGljZSgtbWF4TGluZU51bS50b1N0cmluZygpLmxlbmd0aCk7XG4gICAgY29uc3QgbGluZSA9IG1pblNwYWNlcyA+PSA4ID8gbGluZXNbaWRdLnNsaWNlKG1pblNwYWNlcykgOiBsaW5lc1tpZF07XG4gICAgaWYgKGlkIDw9IGFjdHVhbExpbmVzQmVmb3JlIC0gMSB8fCBpZCA+IGxpbmVzLmxlbmd0aCAtIGFjdHVhbExpbmVzQWZ0ZXIgLSAxKSB7XG4gICAgICBsaW5lc1tpZF0gPSBvdXRwdXRHcmV5KGAke2xpbmVOdW19fCAke2xpbmV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpbmVzW2lkXSA9IGAke291dHB1dEdyZXkoYCR7bGluZU51bX18YCl9JHtvdXRwdXRSZWQoYCAke2xpbmV9YCl9YDtcbiAgICB9XG4gIH0pO1xuXG4gIGNvZGVGcmFtZVN0cmluZyA9IGxpbmVzLmpvaW4oJ1xcbicpO1xuXG4gIHJldHVybiBjb2RlRnJhbWVTdHJpbmc7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBnZXRMb2NhdGlvbkJ5UGF0aDtcbiJdfQ==